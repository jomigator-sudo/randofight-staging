<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>RandoFight - Free Online PvP Fighting Game | Browser RPG</title>

    <!-- Enhanced Meta Tags -->
    <meta name="title" content="RandoFight - Free Online PvP Fighting Game" />
    <meta name="description" content="RandoFight is a free browser-based PvP fighting game with real-time battles, character progression, loot system, and competitive tournaments. Play now!" />
    <meta name="keywords" content="browser game, fighting game, pvp game, online rpg, free game, text-based rpg, incremental game, idle game, randofight" />
    <meta name="author" content="Ninja Roo Games" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://randofight.com/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://randofight.com/" />
    <meta property="og:title" content="RandoFight - Free Online PvP Fighting Game" />
    <meta property="og:description" content="Battle players worldwide in this addictive browser-based fighting game. Level up, collect epic loot, and dominate the leaderboards!" />
    <meta property="og:image" content="https://randofight.com/randofight%20new%20thumbnail.png" />
    <meta property="og:site_name" content="RandoFight" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://randofight.com/" />
    <meta property="twitter:title" content="RandoFight - Free Online PvP Fighting Game" />
    <meta property="twitter:description" content="Battle players worldwide in this addictive browser-based fighting game. Level up, collect epic loot, and dominate the leaderboards!" />
    <meta property="twitter:image" content="https://randofight.com/randofight%20new%20thumbnail.png" />

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://randofight.com/randofight%20header.png" />
    
    <!-- Schema.org structured data for rich snippets -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "RandoFight",
      "description": "Free browser-based PvP fighting game with character progression and tournaments",
      "url": "https://randofight.com",
      "genre": ["Fighting", "RPG", "PvP"],
      "gamePlatform": "Web Browser",
      "applicationCategory": "Game",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.5",
        "ratingCount": "100"
      }
    }
    </script>

    <script src="https://www.paypal.com/sdk/js?client-id=AdSlJbETclTcEvT1E_8m2VuaNbtIvVvaPdAZEDRzMmwS1k8wJV2yhLaMNJ-B0zRLCC9PZrzEq2bFzzsu&currency=USD"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #1a1a2e, #16213e); color: #fff; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .title { text-align: center; font-size: 3em; margin-bottom: 30px; color: #ff6b6b; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .game-screen { display: none; }
        .back-btn { position: absolute; top: 20px; left: 20px; z-index: 100; }
        .fighter-slots { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .fighter-slot { border: 2px solid #4ecdc4; border-radius: 10px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.3s ease; background: rgba(78, 205, 196, 0.1); }
        .fighter-slot:hover { background: rgba(78, 205, 196, 0.2); transform: translateY(-2px); }
        .fighter-slot.locked { border-color: #666; background: rgba(102, 102, 102, 0.1); cursor: not-allowed; }
        .fighter-slot.locked:hover { background: rgba(102, 102, 102, 0.1); transform: none; }
        .slot-number { font-size: 1.2em; color: #4ecdc4; margin-bottom: 10px; }
        .fighter-name { font-size: 1.1em; margin: 10px 0; }
        .fighter-level { color: #ffd93d; }
        .fighter-wins { color: #6bcf7f; }
        .ui-buttons { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
        .btn { padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-family: inherit; font-size: 1em; transition: all 0.3s ease; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-primary { background: #4ecdc4; color: #fff; }
        .btn-primary:hover:not(:disabled) { background: #45b7aa; }
        .btn-secondary { background: #6c5ce7; color: #fff; }
        .btn-secondary:hover { background: #5f4fcf; }
        .btn-fight { background: #ff6b6b; color: #fff; font-weight: bold; box-shadow: 0 4px 8px rgba(255, 107, 107, 0.3); }
        .btn-fight:hover:not(:disabled) { background: #ff5252; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4); }
        .btn-fight:disabled { background: #666; box-shadow: none; }
        .creation-form { max-width: 400px; margin: 0 auto; padding: 20px; background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 5px; color: #4ecdc4; }
        .form-group input { width: 100%; padding: 10px; border: 1px solid #4ecdc4; border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: #fff; font-family: inherit; }
        .fighter-details { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        .stats-panel, .inventory-panel { background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px; }
        .panel-title { font-size: 1.3em; color: #4ecdc4; margin-bottom: 15px; text-align: center; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .equipment-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 15px; }
        .equipment-slot { padding: 8px; border: 1px solid #666; border-radius: 4px; text-align: center; font-size: 0.8em; min-height: 80px; display: flex; flex-direction: column; background: rgba(0, 0, 0, 0.2); }
        .slot-name { font-size: 0.7em; color: #888; margin-bottom: 5px; font-weight: bold; text-transform: uppercase; }
        .item-content { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 3px; }
        .item-power { font-size: 0.8em; color: #ffd93d; font-weight: bold; }
        .item-name { font-size: 0.8em; font-weight: bold; }
        .fight-status { text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; }
        .diamonds-display { font-size: 1.2em; margin-bottom: 10px; color: #ffd93d; }
        .cooldown-timer { color: #e74c3c; font-weight: bold; }
        .fighters-display { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px; }
        .fighter-card { background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px; text-align: center; }
        .hp-bar { width: 100%; height: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; margin: 10px 0; overflow: hidden; }
        .hp-fill { height: 100%; background: #6bcf7f; border-radius: 10px; transition: width 0.5s ease; }
        .fight-log { background: rgba(0, 0, 0, 0.3); padding: 25px; border-radius: 10px; height: 300px; overflow-y: auto; margin-bottom: 20px; font-size: 1em; line-height: 1.4; font-family: 'Courier New', monospace; color: #f0f0f0; }
        .fight-log p { margin-bottom: 8px; text-indent: 0; }
        .story-title { font-size: 1.1em; font-weight: bold; color: #4ecdc4; text-align: center; margin-bottom: 10px; }
        .damage { color: #ff6b6b; font-weight: bold; }
        .heal { color: #6bcf7f; font-weight: bold; }
        .special { color: #ffd93d; font-weight: bold; }
        .critical { color: #ff8c42; font-weight: bold; }
        .dodge { color: #74b9ff; font-style: italic; }
        .victory { color: #00b894; font-weight: bold; font-size: 1.1em; }
        .defeat { color: #e17055; font-weight: bold; }
        .level-up { color: #fdcb6e; font-weight: bold; }
        .exp-gain { color: #81ecec; }
        .leaderboard { background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px; max-height: 400px; overflow-y: auto; }
        .leaderboard-entry { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .leaderboard-entry:nth-child(1) { color: #ffd700; }
        .leaderboard-entry:nth-child(2) { color: #c0c0c0; }
        .leaderboard-entry:nth-child(3) { color: #cd7f32; }
        .common { color: #9d9d9d; }
        .uncommon { color: #1eff00; }
        .rare { color: #0070dd; }
        .epic { color: #a335ee; }
        .legendary { color: #ff8000; }
        .mythic { color: #ff0000; }
        .paypal-button-container { margin: 10px 0; display: inline-block; }
        @media (max-width: 768px) {
    .fighter-details { grid-template-columns: 1fr; }
    .fighters-display { grid-template-columns: 1fr; }
    .title { font-size: 2em; }
    
    /* Fix absolute positioned buttons */
    .back-btn {
        position: static !important;
        margin: 10px auto;
        display: block;
    }
    
    /* Fix overlapping fight buttons */
    #fighterScreen > div[style*="margin-top: 60px"] {
        margin-top: 10px !important;
    }
    
    /* Stack buttons vertically on mobile */
    #fighterScreen .btn-fight,
    #fighterScreen .btn-primary,
    #fighterScreen .btn[onclick*="showWeeklyTournament"] {
        display: block !important;
        width: 100% !important;
        margin: 5px 0 !important;
        padding: 12px 20px !important;
    }
    
    /* Fix button container */
    #fighterScreen > div > div[style*="display: flex"] {
        flex-direction: column !important;
        align-items: stretch !important;
        padding: 0 20px !important;
    }
    
    /* Fix Delete Fighter button */
    #fighterScreen .btn[onclick*="deleteFighter"] {
        position: static !important;
        display: block;
        margin: 10px auto;
        width: 90%;
    }
    
    /* Adjust Equipment grid for mobile */
    .equipment-grid {
        grid-template-columns: repeat(2, 1fr) !important;
    }
    
    /* Fix PayPal button container */
    .paypal-button-container {
        width: 100% !important;
        margin: 5px 0 !important;
    }
    
    /* Fix UI buttons alignment on Character Select screen */
    .ui-buttons {
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    
    .ui-buttons > * {
        width: 90%;
        max-width: 250px;
        margin: 5px 0 !important;
    }
    
    .ui-buttons span {
        margin-right: 0 !important;
    }
    
    /* Stack fighter action buttons vertically on mobile */
    #fighterScreen div[style*="display: flex"] {
        flex-direction: column !important;
        align-items: center !important;
    }
    
    #fighterScreen button {
        width: 90% !important;
        max-width: 250px;
        margin: 5px 0 !important;
    }
}
        .game-screen {
    display: none;
}
        @media (max-width: 768px) {
    /* Add to your existing mobile styles */
    #titleScreen div[style*="margin: 30px 0 20px 0"] {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    
    #titleScreen div[style*="margin: 30px 0 20px 0"] button {
        width: 90%;
        max-width: 300px;
        margin: 0 !important;
    }
}

#fightScreen {
    position: fixed !important;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    z-index: 100;
}

.game-screen * {
    visibility: inherit;
}

#fighterScreen:not([style*="display: block"]) .fighter-details {
    display: none !important;
}
        .company-logo {
  position: fixed;
  bottom: 10px;
  right: 10px;
  width: 80px;
  opacity: 0.8;
  z-index: 1000;
  pointer-events: none;
  display: none; /* ADD THIS LINE */
}

/* Add this to fix header spacing */
.title img {
  display: block;
  margin: 0 auto;
}
        /* Add these CSS classes to your style section */
.player-name { 
    color: #3b82f6; 
    font-weight: bold; 
}
.opponent-name { 
    color: #ff6b6b; 
    font-weight: bold; 
}
.critical-hit-text {
    background: linear-gradient(90deg, #ff8c42, #ffb042);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: bold;
    font-size: 1.1em;
    text-shadow: 0 0 10px rgba(255, 140, 66, 0.5);
}
.special-attack-text {
    background: linear-gradient(90deg, #ffd93d, #ffed4d);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: bold;
    font-size: 1.2em;
    text-shadow: 0 0 15px rgba(255, 217, 61, 0.6);
    display: inline-block;
}
        .speed-burst {
    color: #b19cd9;
    font-weight: bold;
    font-size: 1.05em;
    text-shadow: 0 0 8px rgba(177, 156, 217, 0.5);
}
        .password-toggle-btn {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 8px;
    color: #4ecdc4;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
    line-height: 1;
    min-width: 30px;
    min-height: 30px;
}

.password-toggle-btn:hover {
    color: #6c5ce7;
}

.password-toggle-btn.showing {
    color: #ff6b6b;
}
    
        .event-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 4000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.event-container {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 3px solid #ff6b6b;
    border-radius: 15px;
    padding: 30px;
    max-width: 600px;
    width: 90%;
    box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
}

.event-title {
    color: #ff6b6b;
    font-size: 1.5em;
    text-align: center;
    margin-bottom: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.event-description {
    color: #fff;
    font-size: 1.1em;
    line-height: 1.6;
    margin-bottom: 25px;
    text-align: center;
    padding: 15px;
    background: rgba(255, 107, 107, 0.1);
    border-radius: 8px;
}

.event-timer {
    text-align: center;
    margin-bottom: 20px;
    font-size: 1.2em;
    color: #ffd93d;
    font-weight: bold;
}

.event-timer.urgent {
    color: #ff6b6b;
    animation: pulse 0.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.event-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.event-option {
    background: rgba(78, 205, 196, 0.1);
    border: 2px solid #4ecdc4;
    border-radius: 8px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
}

.event-option:hover {
    background: rgba(78, 205, 196, 0.2);
    transform: translateX(5px);
    border-color: #6c5ce7;
}

.event-option-title {
    color: #4ecdc4;
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 5px;
}

.event-option-stat {
    color: #888;
    font-size: 0.9em;
    margin-bottom: 8px;
}

.event-option-chance {
    color: #ffd93d;
    font-size: 1em;
    font-weight: bold;
}

.event-option-effect {
    color: #ccc;
    font-size: 0.9em;
    margin-top: 5px;
    font-style: italic;
}

@media (max-width: 768px) {
    .event-container {
        padding: 20px;
    }
    
    .event-title {
        font-size: 1.2em;
    }
    
    .event-description {
        font-size: 1em;
    }
}

.clash-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 5000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.clash-container {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 3px solid #ffd93d;
    border-radius: 15px;
    padding: 30px;
    max-width: 600px;
    width: 90%;
    box-shadow: 0 0 30px rgba(255, 217, 61, 0.5);
}

.clash-title {
    color: #ffd93d;
    font-size: 1.8em;
    text-align: center;
    margin-bottom: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    animation: pulse 1s infinite;
}

.clash-timer {
    text-align: center;
    margin-bottom: 20px;
    font-size: 1.5em;
    color: #ff6b6b;
    font-weight: bold;
}

.clash-info {
    background: rgba(255,255,255,0.1);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.clash-fighters {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 20px;
    align-items: center;
    margin-bottom: 20px;
}

.clash-fighter {
    text-align: center;
}

.clash-fighter-name {
    color: #4ecdc4;
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 5px;
}

.clash-attack-name {
    color: #ffd93d;
    font-size: 1em;
    margin-bottom: 10px;
}

.clash-damage {
    color: #ff6b6b;
    font-size: 1.3em;
    font-weight: bold;
}

.clash-vs {
    color: #fff;
    font-size: 2em;
    font-weight: bold;
}

.clash-bar-container {
    width: 100%;
    height: 40px;
    background: rgba(0,0,0,0.3);
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    margin-bottom: 20px;
}

.clash-bar {
    position: absolute;
    top: 0;
    height: 100%;
    transition: width 0.5s ease;
}

.clash-bar-player {
    left: 0;
    background: linear-gradient(90deg, #4ecdc4, #6c5ce7);
}

.clash-bar-opponent {
    right: 0;
    background: linear-gradient(90deg, #ff6b6b, #ff8c42);
}

.clash-center-line {
    position: absolute;
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    background: #fff;
    z-index: 1;
}

@keyframes clashShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

.clashing {
    animation: clashShake 0.1s infinite;
}
        
    </style>
</head>
<body>
        <!-- Loading Screen -->
    <div id="loadingScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #1a1a2e, #16213e); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <img src="https://randofight.com/randofight%20header.png" alt="Randofight" style="max-width: 400px; width: 80%; margin-bottom: 30px;">
        
        <div style="width: 200px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-bottom: 20px;">
            <div id="loadingBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4ecdc4, #6c5ce7); border-radius: 3px; transition: width 0.3s ease;"></div>
        </div>
        
        <div id="loadingText" style="color: #4ecdc4; font-size: 1.2em; font-family: 'Courier New', monospace;">Loading game data...</div>
        
        <div style="margin-top: 40px;">
            <div class="spinner" style="width: 40px; height: 40px; border: 4px solid rgba(78, 205, 196, 0.3); border-top-color: #4ecdc4; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    
        <img src="https://randofight.com/ninja%20roo%20logo%20white.png" 
     alt="Ninja Roo Games" 
     class="company-logo">
    <div class="container">
    <!-- Navigation header with back button and title -->
<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;"> <!-- Reduced from 20px -->
    <button id="globalBackBtn" class="btn btn-secondary" onclick="handleBackButton()" style="display: none;">‚Üê Back</button>
    
    <h1 class="title" style="margin: 0; flex-grow: 1; text-align: center; line-height: 1;">
      <img 
        src="https://randofight.com/randofight%20header.png" 
        alt="Randofight" 
        style="max-width: 400px; width: 100%; height: auto; display: block; margin: 0 auto;" />
    </h1>

    <div style="width: 80px;"></div> <!-- Spacer for centering -->
</div>

        <!-- Login Screen -->
<div id="loginScreen" class="game-screen" style="display: block;">
    <div style="text-align: center; margin-bottom: 30px;">
        <h2 style="color: #4ecdc4; font-size: 2.5em; margin-bottom: 10px;">Welcome to RandoFight</h2>
        <p style="color: #ccc; font-size: 1.1em;">Login or create an account to save your progress</p>
    </div>

    <div class="creation-form">
        <div id="loginForm">
    <h3 style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Login</h3>
    <div class="form-group">
        <label for="loginEmail">Email:</label>
        <input type="email" id="loginEmail" placeholder="Enter your email">
    </div>
<div class="form-group">
    <label for="loginPassword">Password:</label>
    <div style="position: relative; width: 100%;">
        <input type="password" id="loginPassword" placeholder="Enter your password" style="padding-right: 45px; width: 100%;">
        <button type="button" onclick="togglePasswordVisibility('loginPassword', 'loginPasswordToggle')" id="loginPasswordToggle" class="password-toggle-btn">
            Show
        </button>
    </div>
</div>
    <div style="text-align: center; margin-top: 20px;">
        <button class="btn btn-primary" onclick="loginUser()">Login</button>
        <button class="btn btn-secondary" onclick="showSignupForm()">Create Account</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
        <button class="btn" style="background: #6c757d; color: #fff; font-size: 0.9em;" onclick="showForgotPasswordForm()">Forgot Password?</button>
    </div>
    <div style="text-align: center; margin-top: 20px; border-top: 1px solid #444; padding-top: 15px;">
        <button class="btn" style="background: #28a745; color: #fff; font-size: 1em; padding: 12px 24px;" onclick="playAsGuest()">Play as Guest</button>
        <p style="color: #888; font-size: 0.8em; margin-top: 10px;">Play without an account (progress saved locally)</p>
    </div>
</div>
        </div>

        <div id="signupForm" style="display: none;">
    <h3 style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Create Account</h3>
    <div class="form-group">
        <label for="signupEmail">Email:</label>
        <input type="email" id="signupEmail" placeholder="Enter your email">
    </div>
<div class="form-group">
    <label for="signupPassword">Password:</label>
    <div style="position: relative; width: 100%;">
        <input type="password" id="signupPassword" placeholder="Choose a password (min 6 characters)" style="padding-right: 45px; width: 100%;">
        <button type="button" onclick="togglePasswordVisibility('signupPassword', 'signupPasswordToggle')" id="signupPasswordToggle" class="password-toggle-btn">
            Show
        </button>
    </div>
</div>
    <div class="form-group">
        <label for="signupUsername">Username:</label>
        <input type="text" id="signupUsername" placeholder="Choose a username" maxlength="20">
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button class="btn btn-primary" onclick="signupUser()">Create Account</button>
        <button class="btn btn-secondary" onclick="showLoginForm()">Back to Login</button>
    </div>
</div>

        <div id="forgotPasswordForm" style="display: none;">
            <h3 style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Reset Password</h3>
            <p style="text-align: center; margin-bottom: 20px; color: #ccc; font-size: 0.9em;">
                Enter your email address and we'll send you a link to reset your password.
            </p>
            <div class="form-group">
                <label for="resetEmail">Email:</label>
                <input type="email" id="resetEmail" placeholder="Enter your email address">
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-primary" onclick="sendPasswordReset()">Send Reset Link</button>
                <button class="btn btn-secondary" onclick="showLoginForm()">Back to Login</button>
            </div>
        </div>

        <div id="resetPasswordForm" style="display: none;">
    <h3 style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Set New Password</h3>
    <p style="text-align: center; margin-bottom: 20px; color: #ccc; font-size: 0.9em;">
        Enter your new password below.
    </p>
<div class="form-group">
    <label for="newPassword">New Password:</label>
    <div style="position: relative; width: 100%;">
        <input type="password" id="newPassword" placeholder="Enter new password (min 6 characters)" style="padding-right: 45px; width: 100%;">
        <button type="button" onclick="togglePasswordVisibility('newPassword', 'newPasswordToggle')" id="newPasswordToggle" class="password-toggle-btn">
            Show
        </button>
    </div>
</div>
<div class="form-group">
    <label for="confirmPassword">Confirm Password:</label>
    <div style="position: relative; width: 100%;">
        <input type="password" id="confirmPassword" placeholder="Confirm new password" style="padding-right: 45px; width: 100%;">
        <button type="button" onclick="togglePasswordVisibility('confirmPassword', 'confirmPasswordToggle')" id="confirmPasswordToggle" class="password-toggle-btn">
            Show
        </button>
    </div>
</div>
    <div style="text-align: center; margin-top: 20px;">
        <button class="btn btn-primary" onclick="resetPassword()">Update Password</button>
        <button class="btn btn-secondary" onclick="showLoginForm()">Back to Login</button>
    </div>
</div>
    <!-- Credits and News Buttons -->
<div style="text-align: center; margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
    <button class="btn" style="background: rgba(255,255,255,0.1); color: #888; padding: 8px 20px; font-size: 0.85em;" onclick="showNewsModal()">üì∞ News</button>
    <button class="btn" style="background: rgba(255,255,255,0.1); color: #888; padding: 8px 20px; font-size: 0.85em;" onclick="showCreditsModal()">‚ÑπÔ∏è Credits</button>
</div>
</div> <!-- This closes loginScreen -->
</div>

<!-- Character Select Screen -->
<div id="titleScreen" class="game-screen" style="display: none;">
    <div style="text-align: center; margin-bottom: 30px; margin-top: 20px;">
        <h2 style="color: #4ecdc4; font-size: 2.5em; margin-bottom: 10px;">Character Select</h2>
        <p style="color: #ccc; font-size: 1.1em;">Welcome back, <span id="usernameDisplay">Player</span>!</p>
        <div style="background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; border-radius: 5px; padding: 10px; margin: 15px auto; max-width: 600px;">
            <p style="color: #22c55e; font-size: 0.9em; margin: 0;">‚úÖ <strong>Cloud Save Enabled:</strong> Your characters are automatically saved and will persist across devices and sessions!</p>
        </div>
    </div>

    <div class="ui-buttons">
        <span style="color: #ffd93d; font-size: 1.2em; margin-right: 20px;">Diamonds: <span id="titleDiamonds">0</span> üíé</span>
        <div id="titlePaypalButton" class="paypal-button-container"></div>
        <button class="btn btn-secondary" onclick="showGlobalLeaderboard()">Leaderboard</button>
        <button class="btn" style="background: #ffd93d; color: #333;" onclick="showWeeklyTournament()">üèÜ Weekly</button>
        <button class="btn" style="background: #4ecdc4; color: #fff;" onclick="showDailyTasks()">üìÖ Daily</button>
    </div>

    <div class="fighter-slots">
        <!-- Fighter slot HTML -->
        <div class="fighter-slot" id="slot-container-0" onclick="selectFighter(0)">
            <div class="slot-number">Slot 1</div>
            <div class="fighter-name">Empty Slot</div>
            <div>Click to create fighter</div>
        </div>
        <div class="fighter-slot locked" id="slot-container-1" onclick="purchaseSlot(1)">
            <div class="slot-number">Slot 2</div>
            <div>Purchase this slot for 200 üíé</div>
        </div>
        <div class="fighter-slot locked" id="slot-container-2" onclick="purchaseSlot(2)">
            <div class="slot-number">Slot 3</div>
            <div>Purchase this slot for 200 üíé</div>
        </div>
        <div class="fighter-slot locked" id="slot-container-3" onclick="purchaseSlot(3)">
            <div class="slot-number">Slot 4</div>
            <div>Purchase this slot for 200 üíé</div>
        </div>
        <div class="fighter-slot locked" id="slot-container-4" onclick="purchaseSlot(4)">
            <div class="slot-number">Slot 5</div>
            <div>Purchase this slot for 200 üíé</div>
        </div>
    </div>
    
    <!-- Refer, Discord and Logout buttons at bottom -->
    <div style="text-align: center; margin: 30px 0 20px 0;">
        <button class="btn" style="background: #ffd93d; color: #333; padding: 10px 30px; margin-right: 10px; font-weight: bold;" onclick="showReferralModal()">üéÅ Refer Friends</button>
        <button class="btn" style="background: #5865F2; color: #fff; padding: 10px 30px; margin-right: 10px;" onclick="openDiscord()">
            <svg style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px;" viewBox="0 0 71 55" fill="none">
                <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="currentColor"/>
            </svg>
            Join Discord
        </button>
        <button class="btn btn-secondary" onclick="logoutUser()" style="padding: 10px 30px;">Logout</button>
    </div>
        <!-- Credits and News Buttons -->
<div style="text-align: center; margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
    <button class="btn" style="background: rgba(255,255,255,0.1); color: #888; padding: 8px 20px; font-size: 0.85em;" onclick="showNewsModal()">üì∞ News</button>
    <button class="btn" style="background: rgba(255,255,255,0.1); color: #888; padding: 8px 20px; font-size: 0.85em;" onclick="showCreditsModal()">‚ÑπÔ∏è Credits</button>
</div>
</div> <!-- This closes titleScreen -->

<!-- Fighter Creation Screen -->
<div id="creationScreen" class="game-screen">
    <div class="creation-form">
        <h2 style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Create New Fighter</h2>
        <div class="form-group">
            <label for="fighterName">Fighter Name:</label>
            <input type="text" id="fighterName" maxlength="20" placeholder="Enter fighter name" oninput="validateFighterNameInput()">
            <div id="nameError" style="color: #e74c3c; font-size: 0.9em; margin-top: 8px; min-height: 20px; display: none;"></div>
            <div style="margin-top: 10px; font-size: 0.85em; color: #888;">
                <p>‚Ä¢ 3-20 characters required</p>
                <p>‚Ä¢ Must contain at least one letter</p>
                <p>‚Ä¢ Inappropriate names will be blocked</p>
            </div>
        </div>
        <div style="text-align: center; margin-top: 30px;">
            <button class="btn btn-primary" onclick="createFighter()">Create Fighter</button>
            <button class="btn btn-secondary" onclick="showTitleScreen()">Cancel</button>
        </div>
        <div style="text-align: center; margin-top: 20px; color: #888; font-size: 0.9em;">
            <p>üî• Your fighter will unlock a special attack at level 10! üî•</p>
        </div>
    </div>
</div>

<!-- Fighter Details Screen -->
<div id="fighterScreen" class="game-screen">
    <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; padding: 0 10px;">
    
    <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; padding: 0 10px;">
        <button class="btn btn-fight" onclick="findFight()" id="fightBtn" style="padding: 10px 18px; font-size: 0.9em;">Find Fight</button>
        <button class="btn btn-primary" onclick="fightWithoutRest()" id="fightWithoutRestBtn" style="padding: 10px 18px; font-size: 0.9em;">Fight üíé</button>
        <button class="btn" style="background: #ffd93d; color: #333; padding: 10px 18px; font-size: 0.9em;" onclick="showWeeklyTournamentFromFighter()">üèÜ Weekly Tournament</button>
        <button class="btn" style="background: #4ecdc4; color: #fff; padding: 10px 18px; font-size: 0.9em;" onclick="showDailyTasks()">üìÖ Daily</button>
        <div id="fighterPaypalButton" class="paypal-button-container"></div>
    </div>
    </div>
    <div class="fight-status">
        <div class="diamonds-display">Diamonds: <span id="diamonds">0</span> üíé</div>
        <div class="cooldown-timer" id="cooldownTimer"></div>
    </div>
    
    <div class="fighter-details">
        <div class="stats-panel">
            <h3 class="panel-title">Fighter Stats</h3>
            <div id="fighterStats"></div>
        </div>
        <div class="inventory-panel">
            <h3 class="panel-title">Equipment</h3>
            <div id="fighterEquipment" class="equipment-grid"></div>
        </div>
    </div>
    
    <!-- Delete Fighter button at bottom -->
    <div style="text-align: center; margin: 30px 0 20px 0;">
        <button class="btn" style="background: #e74c3c; color: #fff; padding: 12px 30px;" onclick="deleteFighter();">Delete Fighter</button>
    </div>
    
    <!-- NO DEVELOPER CREDITS HERE -->
</div>

<!-- Fight Screen -->
<div id="fightScreen" class="game-screen">
<div class="fighters-display" style="margin-top: 40px;">
    <div class="fighter-card">
        <h3 id="player1Name">Your Fighter</h3>
        <div class="hp-bar">
            <div id="player1HP" class="hp-fill" style="width: 100%"></div>
        </div>
        <div id="player1Info">HP: <span id="player1HPText">100/100</span></div>
        <div style="margin-top: 10px;">
            <div style="font-size: 0.8em; color: #ffd93d; margin-bottom: 3px;">Special Attack</div>
            <div style="width: 100%; height: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; overflow: hidden; border: 1px solid #ffd93d;">
                <div id="player1Special" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ffd93d, #ffed4d); transition: width 0.3s ease;"></div>
            </div>
        </div>
        <button id="player1SpecialBtn" class="btn" style="background: #ffd93d; color: #333; margin-top: 8px; padding: 6px 12px; font-size: 0.85em; display: none;" onclick="playerUseSpecial()">Use Special Attack</button>
    </div>
    <div class="fighter-card">
        <h3 id="player2Name">Opponent</h3>
        <div class="hp-bar">
            <div id="player2HP" class="hp-fill" style="width: 100%"></div>
        </div>
        <div id="player2Info">HP: <span id="player2HPText">100/100</span></div>
        <div style="margin-top: 10px;">
            <div style="font-size: 0.8em; color: #ffd93d; margin-bottom: 3px;">Special Attack</div>
            <div style="width: 100%; height: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; overflow: hidden; border: 1px solid #ffd93d;">
                <div id="player2Special" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff6b6b, #ff8c42); transition: width 0.3s ease;"></div>
            </div>
        </div>
    </div>
</div>
            <div id="fightLog" class="fight-log"></div>
<div style="text-align: center; margin-top: 20px;">
    <button class="btn btn-secondary" onclick="endFight()" id="endFightBtn" style="display: none; margin: 0 auto;">Continue</button>
</div>
        </div>
        </div>

    <script>
        // Supabase configuration
        var SUPABASE_URL = 'https://pmsbxvqavkoboxyhqjcc.supabase.co';
        var SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U';
        
        var gameState = {
    fighters: [],
    currentFighter: null,
    diamonds: 0,
    fightCooldownEnd: 0,
    unlockedSlots: [true, false, false, false, false],
    currentSlotIndex: 0,
    currentUser: null,
    isLoggedIn: false,
    currentBoss: null, // Add this line
    dailyTasks: {
        lastReset: new Date().toDateString(),
        winsToday: 0,
        claimed: {
            win3: false,
            win5: false,
            win10: false,
            win20: false,
            win30: false
        }
    }
};

var fightPaused = false;       
var clashTimer = null;
var clashTimeLeft = 10;
        
// Add these functions near the top of your script section, after the gameState declaration

function updateLoadingProgress(percent, message) {
    var loadingBar = document.getElementById('loadingBar');
    var loadingText = document.getElementById('loadingText');
    
    if (loadingBar) {
        loadingBar.style.width = percent + '%';
    }
    if (loadingText && message) {
        loadingText.textContent = message;
    }
}

function hideLoadingScreen() {
    var loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        loadingScreen.style.transition = 'opacity 0.5s ease';
        setTimeout(function() {
            loadingScreen.style.display = 'none';
        }, 500);
    }
}
        function openDiscord() {
    // Replace this with your actual Discord server invite link
    window.open('https://discord.gg/pahwAY8HGK', '_blank');
}
        function showDiscordWidget() {
    var modal = 
        '<div id="discordModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; border: 2px solid #5865F2; max-width: 400px; width: 90%;">' +
                '<h2 style="color: #5865F2; text-align: center; margin-bottom: 20px;">Join Our Discord!</h2>' +
                '<iframe src="https://discord.com/widget?id=YOUR_SERVER_ID&theme=dark" width="100%" height="400" allowtransparency="true" frameborder="0" sandbox="allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts"></iframe>' +
                '<div style="text-align: center; margin-top: 15px;">' +
                    '<button class="btn btn-primary" onclick="openDiscord()" style="margin-right: 10px;">Join Discord</button>' +
                    '<button class="btn btn-secondary" onclick="closeDiscordModal()">Close</button>' +
                '</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modal);
}

function closeDiscordModal() {
    var modal = document.getElementById('discordModal');
    if (modal) modal.remove();
}
        
        function togglePasswordVisibility(inputId, buttonId) {
    var input = document.getElementById(inputId);
    var button = document.getElementById(buttonId);
    
    if (!input || !button) return;
    
    if (input.type === 'password') {
        // Password is currently hidden, show it
        input.type = 'text';
        button.textContent = 'Hide'; // Now showing, so button says "Hide"
        button.classList.add('showing');
    } else {
        // Password is currently visible, hide it
        input.type = 'password';
        button.textContent = 'Show'; // Now hidden, so button says "Show"
        button.classList.remove('showing');
    }
}
        
        // Special attack word combinations for dynamic generation
var specialAttackPrefixes = ['Dark', 'Light', 'Fire', 'Ice', 'Thunder', 'Shadow', 'Dragon', 'Phoenix', 'Storm', 'Chaos', 
    'Divine', 'Mystic', 'Crimson', 'Azure', 'Golden', 'Silver', 'Void', 'Cosmic', 'Lunar', 'Solar', 
    'Inferno', 'Frost', 'Lightning', 'Venom', 'Crystal', 'Iron', 'Titan', 'Demon', 'Angel', 'Spirit',
    'Phantom', 'Blazing', 'Frozen', 'Electric', 'Savage', 'Ancient', 'Primal', 'Eternal', 'Astral', 'Meteor'];

var specialAttackSuffixes = ['Strike', 'Slam', 'Punch', 'Fist', 'Crash', 'Wave', 'Beam', 'Blast', 'Rush', 'Fury',
    'Claw', 'Kick', 'Crusher', 'Breaker', 'Buster', 'Storm', 'Rage', 'Impact', 'Nova', 'Burst',
    'Blade', 'Edge', 'Flash', 'Smash', 'Force', 'Wrath', 'Destruction', 'Annihilation', 'Devastation', 'Rampage',
    'Assault', 'Barrage', 'Cyclone', 'Vortex', 'Eruption', 'Avalanche', 'Tempest', 'Maelstrom', 'Cataclysm', 'Apocalypse'];

function generateSpecialAttackName() {
    var prefix = specialAttackPrefixes[Math.floor(Math.random() * specialAttackPrefixes.length)];
    var suffix = specialAttackSuffixes[Math.floor(Math.random() * specialAttackSuffixes.length)];
    return prefix + ' ' + suffix;
}
        var equipmentSlots = ['Weapon', 'Off-Hand', 'Helmet', 'Shoulders', 'Gloves', 'Chest', 'Greaves', 'Boots'];

        // EmailJS Configuration
        var EMAILJS_PUBLIC_KEY = 'K5NaITkysVL6hhc2A';
        var EMAILJS_SERVICE_ID = 'service_22pzu4g';
        var EMAILJS_TEMPLATE_ID = 'template_38r3g5c';

        // PayPal Configuration
        var PAYPAL_CLIENT_ID = 'AdSlJbETclTcEvT1E_8m2VuaNbtIvVvaPdAZEDRzMmwS1k8wJV2yhLaMNJ-B0zRLCC9PZrzEq2bFzzsu';

        // Initialize EmailJS
        function initEmailJS() {
            console.log('Checking EmailJS availability...');
            console.log('typeof emailjs:', typeof emailjs);
            console.log('Public key:', EMAILJS_PUBLIC_KEY);
            
            if (typeof emailjs !== 'undefined' && EMAILJS_PUBLIC_KEY !== 'YOUR_EMAILJS_PUBLIC_KEY') {
                try {
                    emailjs.init(EMAILJS_PUBLIC_KEY);
                    console.log('EmailJS initialized successfully');
                    return true;
                } catch (error) {
                    console.error('EmailJS initialization error:', error);
                    return false;
                }
            } else {
                console.log('EmailJS not available or not configured');
                console.log('emailjs undefined:', typeof emailjs === 'undefined');
                console.log('Public key not set:', EMAILJS_PUBLIC_KEY === 'YOUR_EMAILJS_PUBLIC_KEY');
                return false;
            }
        }

        // Initialize PayPal Buttons
function initPayPalButtons() {
    // Clear existing buttons and labels first to prevent duplicates
    var titleContainer = document.getElementById('titlePaypalButton');
    var fighterContainer = document.getElementById('fighterPaypalButton');
    
    if (titleContainer) {
        titleContainer.innerHTML = '';
        // Remove any existing labels
        var existingLabel = titleContainer.previousElementSibling;
        if (existingLabel && existingLabel.innerHTML && existingLabel.innerHTML.includes('Buy 20')) {
            existingLabel.remove();
        }
    }
    if (fighterContainer) {
        fighterContainer.innerHTML = '';
        // Remove any existing labels
        var existingLabel = fighterContainer.previousElementSibling;
        if (existingLabel && existingLabel.innerHTML && existingLabel.innerHTML.includes('Buy 20')) {
            existingLabel.remove();
        }
    }
    
    // Replace PayPal buttons with Shop buttons
    if (titleContainer) {
        titleContainer.innerHTML = '<button class="btn btn-primary" onclick="showDiamondShop()">Shop</button>';
    }
    
    if (fighterContainer) {
        fighterContainer.innerHTML = '<button class="btn btn-primary" onclick="showDiamondShop()">Shop</button>';
    }
}

function handleBackButton() {
    // Determine which screen is currently active and go back appropriately
    if (document.getElementById('fighterScreen').style.display === 'block') {
        document.getElementById('globalBackBtn').style.display = 'none'; // Hide back button
        showTitleScreen();
    } else if (document.getElementById('creationScreen').style.display === 'block') {
        document.getElementById('globalBackBtn').style.display = 'none'; // Hide back button
        showTitleScreen();
    }
}

// Update showFighterScreen to show the back button
function showFighterScreen() {
    try {
        console.log('showFighterScreen called');
        console.log('Current fighter:', gameState.currentFighter);
        
        hideAll();
        
        // Explicitly show the back button for fighter screen
        document.getElementById('globalBackBtn').style.display = 'block';
        
        var fighterScreen = document.getElementById('fighterScreen');
        
        updateFighterDisplay();
        console.log('Fighter display updated');
        
        updateFightStatus();
        console.log('Fight status updated');
        
        setTimeout(function() {
            initPayPalButtons();
        }, 100);
    } catch (error) {
        console.error('Error in showFighterScreen:', error);
        alert('Error displaying character screen: ' + error.message + '\nCheck console for details');
    }
}

// Update showTitleScreen to hide the back button
function showTitleScreen() {
    try {
        hideAll();
        document.getElementById('globalBackBtn').style.display = 'none'; // Hide back button
        document.getElementById('titleScreen').style.display = 'block';
        updateFighterSlots();
        updateDiamondDisplay();
        
        // Update the logout/create account button based on account type
        var logoutBtn = document.querySelector('button[onclick="logoutUser()"]') || 
                       document.querySelector('.btn-secondary[onclick="logoutUser()"]');
        
        // Also check for the create account button
        if (!logoutBtn) {
            var allButtons = document.querySelectorAll('#titleScreen button');
            for (var i = 0; i < allButtons.length; i++) {
                if (allButtons[i].textContent.includes('Logout') || allButtons[i].textContent.includes('Create Account')) {
                    logoutBtn = allButtons[i];
                    break;
                }
            }
        }
        
        if (logoutBtn) {
            // Check if user is a guest
            if (gameState.currentUser && gameState.currentUser.isGuest) {
                console.log('Setting button to Create Account for guest');
                logoutBtn.textContent = 'Create Account';
                logoutBtn.removeAttribute('onclick');
                logoutBtn.onclick = createAccountFromGuest;
            } else {
                console.log('Setting button to Logout for logged-in user');
                logoutBtn.textContent = 'Logout';
                logoutBtn.removeAttribute('onclick');
                logoutBtn.onclick = logoutUser;
            }
        }
        
        // Update cloud save message based on account type
        var cloudSaveMessage = document.querySelector('div[style*="background: rgba(34, 197, 94, 0.2)"]') ||
                              document.querySelector('div[style*="background: rgba(245, 158, 11, 0.2)"]');
        
        if (cloudSaveMessage) {
            if (gameState.currentUser && gameState.currentUser.isGuest) {
                cloudSaveMessage.innerHTML = '<p style="color: #f59e0b; font-size: 0.9em; margin: 0;">‚ö†Ô∏è <strong>Playing as Guest:</strong> Your progress is saved locally. Create an account to sync across devices!</p>';
                cloudSaveMessage.style.background = 'rgba(245, 158, 11, 0.2)';
                cloudSaveMessage.style.borderColor = '#f59e0b';
            } else {
                cloudSaveMessage.innerHTML = '<p style="color: #22c55e; font-size: 0.9em; margin: 0;">‚úÖ <strong>Cloud Save Enabled:</strong> Your characters are automatically saved and will persist across devices and sessions!</p>';
                cloudSaveMessage.style.background = 'rgba(34, 197, 94, 0.2)';
                cloudSaveMessage.style.borderColor = '#22c55e';
            }
        }
        
        // Check for weekly prizes when entering title screen
        setTimeout(function() {
            try {
                checkWeeklyPrizes();
            } catch (e) {
                console.error('Error checking weekly prizes:', e);
            }
        }, 1000);
        
        // Initialize PayPal buttons when title screen is shown
        setTimeout(function() {
            try {
                initPayPalButtons();
            } catch (e) {
                console.error('Error initializing PayPal buttons:', e);
            }
        }, 100);
    } catch (error) {
        console.error('Error in showTitleScreen:', error);
        alert('Error loading character select screen. Check console for details.');
    }
}

// Update showCreationScreen to show the back button
function showCreationScreen() {
    hideAll();
    document.getElementById('globalBackBtn').style.display = 'block'; // Show back button
    document.getElementById('creationScreen').style.display = 'block';
    document.getElementById('fighterName').value = '';
}
        // Show Diamond Shop Modal
        function showDiamondShop() {
    var existingModal = document.getElementById('diamondShopModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="diamondShopModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 450px; text-align: center; width: 90%; max-height: 90vh; overflow-y: auto;">' +
                '<h3 style="color: #4ecdc4; margin-bottom: 20px;">Diamond Shop</h3>' +
                '<p style="margin-bottom: 20px; color: #ccc; font-size: 0.9em;">Purchase diamonds to unlock slots, fight without cooldown, and more!</p>' +
                '<div style="display: grid; gap: 15px; margin-bottom: 20px;">' +
                    '<div class="diamond-pack" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border: 1px solid #666;">' +
                        '<div style="color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">100 üíé</div>' +
                        '<div style="color: #4ecdc4; font-size: 1.2em; margin-bottom: 5px;">$0.99</div>' +
                        '<div style="color: #888; font-size: 0.75em; margin-bottom: 10px;">$0.0099 per diamond</div>' +
                        '<div style="background: rgba(255,255,255,0.95); padding: 10px; border-radius: 6px; min-height: 40px;">' +
                            '<div id="pack1Button"></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="diamond-pack" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border: 1px solid #666;">' +
                        '<div style="color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">250 üíé</div>' +
                        '<div style="color: #4ecdc4; font-size: 1.2em; margin-bottom: 5px;">$1.99</div>' +
                        '<div style="color: #888; font-size: 0.75em; margin-bottom: 10px;">$0.0080 per diamond <span style="color: #6bcf7f;">(19% bonus!)</span></div>' +
                        '<div style="background: rgba(255,255,255,0.95); padding: 10px; border-radius: 6px; min-height: 40px;">' +
                            '<div id="pack2Button"></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="diamond-pack" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border: 1px solid #666; border-color: #ff6b6b;">' +
                        '<div style="color: #ff6b6b; font-size: 0.8em; margin-bottom: 5px;">POPULAR</div>' +
                        '<div style="color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">700 üíé</div>' +
                        '<div style="color: #4ecdc4; font-size: 1.2em; margin-bottom: 5px;">$4.99</div>' +
                        '<div style="color: #888; font-size: 0.75em; margin-bottom: 10px;">$0.0071 per diamond <span style="color: #6bcf7f;">(40% bonus!)</span></div>' +
                        '<div style="background: rgba(255,255,255,0.95); padding: 10px; border-radius: 6px; min-height: 40px;">' +
                            '<div id="pack3Button"></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="diamond-pack" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border: 1px solid #666; border-color: #ffd700;">' +
                        '<div style="color: #ffd700; font-size: 0.8em; margin-bottom: 5px;">BEST VALUE</div>' +
                        '<div style="color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">1,700 üíé</div>' +
                        '<div style="color: #4ecdc4; font-size: 1.2em; margin-bottom: 5px;">$9.99</div>' +
                        '<div style="color: #888; font-size: 0.75em; margin-bottom: 10px;">$0.0059 per diamond <span style="color: #6bcf7f;">(70% bonus!)</span></div>' +
                        '<div style="background: rgba(255,255,255,0.95); padding: 10px; border-radius: 6px; min-height: 40px;">' +
                            '<div id="pack4Button"></div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<button class="btn btn-secondary" onclick="closeDiamondShop()" style="width: 100%; padding: 8px;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Initialize PayPal buttons for each pack
    if (typeof paypal !== 'undefined') {
        initShopPayPalButton('pack1Button', '0.99', 100);
        initShopPayPalButton('pack2Button', '1.99', 250);
        initShopPayPalButton('pack3Button', '4.99', 700);
        initShopPayPalButton('pack4Button', '9.99', 1700);
    } else {
        // Fallback if PayPal not available
        document.getElementById('pack1Button').innerHTML = '<button class="btn btn-primary" onclick="fallbackPurchase(100)" style="width: 100%; font-size: 0.9em;">Purchase (Test)</button>';
        document.getElementById('pack2Button').innerHTML = '<button class="btn btn-primary" onclick="fallbackPurchase(250)" style="width: 100%; font-size: 0.9em;">Purchase (Test)</button>';
        document.getElementById('pack3Button').innerHTML = '<button class="btn btn-primary" onclick="fallbackPurchase(700)" style="width: 100%; font-size: 0.9em;">Purchase (Test)</button>';
        document.getElementById('pack4Button').innerHTML = '<button class="btn btn-primary" onclick="fallbackPurchase(1700)" style="width: 100%; font-size: 0.9em;">Purchase (Test)</button>';
    }
}

        function initShopPayPalButton(containerId, price, diamonds) {
    paypal.Buttons({
        createOrder: function(data, actions) {
            return actions.order.create({
                purchase_units: [{
                    amount: {
                        value: price,
                        currency_code: 'USD'
                    },
                    description: diamonds + ' Diamonds for RandoFight'
                }],
                application_context: {
                    brand_name: 'RandoFight',
                    locale: 'en-US',
                    shipping_preference: 'NO_SHIPPING'
                }
            });
        },
        onApprove: function(data, actions) {
            return actions.order.capture().then(function(details) {
                console.log('PayPal payment successful:', details);
                closeDiamondShop();
                processSuccessfulPayment(details, diamonds);
            });
        },
        onError: function(err) {
            console.error('PayPal payment error:', err);
            alert('Payment failed. Please try again.');
        },
        onCancel: function(data) {
            console.log('PayPal payment cancelled:', data);
        },
        style: {
            color: 'blue',
            shape: 'pill',
            label: 'pay',
            height: 35,
            tagline: false
        }
    }).render('#' + containerId);
}

        function closeDiamondShop() {
            var modal = document.getElementById('diamondShopModal');
            if (modal) {
                modal.remove();
            }
        }

        function processSuccessfulPayment(paymentDetails, diamonds) {
            console.log('Processing PayPal payment:', paymentDetails);
            
            gameState.diamonds += diamonds || 20;
            saveToSupabase();
            updateDiamondDisplay();
            updateFightStatus();
            alert('Payment successful! ' + (diamonds || 20) + ' Diamonds have been added to your account.');
        }

        // Fallback purchase function for when PayPal is not available
        function fallbackPurchase(diamonds) {
            closeDiamondShop();
            gameState.diamonds += diamonds || 20;
            saveToSupabase();
            updateDiamondDisplay();
            updateFightStatus();
            alert((diamonds || 20) + ' Diamonds purchased! (Test Mode - PayPal not loaded)');
        }

        // Fallback purchase function for when PayPal is not available
        function purchaseDiamonds() {
            if (typeof paypal !== 'undefined') {
                console.log('PayPal is available, opening diamond shop');
                showDiamondShop();
            } else {
                console.log('PayPal not available, using test purchase');
                gameState.diamonds += 20;
                saveToSupabase();
                updateDiamondDisplay();
                updateFightStatus();
                alert('20 Diamonds purchased! (Test Mode - PayPal not loaded)');
            }
        }

        function getUserId() {
            if (gameState.currentUser && gameState.currentUser.user_id) {
                return gameState.currentUser.user_id;
            }
            var userId = localStorage.getItem('randofight_user_id');
            if (!userId) {
                userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('randofight_user_id', userId);
            }
            return userId;
        }

        // Authentication functions
        function checkExistingSession() {
            try {
                var session = localStorage.getItem('randofight_session');
                console.log('Checking session:', session ? 'Found' : 'Not found');
                
                if (session) {
                    var sessionData = JSON.parse(session);
                    console.log('Session data:', sessionData);
                    
                    var thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                    if (sessionData.loginTime > thirtyDaysAgo) {
                        gameState.currentUser = sessionData;
                        gameState.isLoggedIn = true;
                        
                        var usernameElement = document.getElementById('usernameDisplay');
                        if (usernameElement) {
                            usernameElement.textContent = sessionData.username;
                        }
                        
                        console.log('Restored session for:', sessionData.username);
                        return true;
                    } else {
                        console.log('Session expired, removing...');
                        localStorage.removeItem('randofight_session');
                    }
                } else {
                    console.log('No session found in localStorage');
                }
            } catch (error) {
                console.error('Session restore error:', error);
                localStorage.removeItem('randofight_session');
            }
            return false;
        }

        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function showLoginForm() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('signupForm').style.display = 'none';
            document.getElementById('forgotPasswordForm').style.display = 'none';
            document.getElementById('resetPasswordForm').style.display = 'none';
        }

        function showSignupForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'block';
            document.getElementById('forgotPasswordForm').style.display = 'none';
            document.getElementById('resetPasswordForm').style.display = 'none';
        }

        function showForgotPasswordForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'none';
            document.getElementById('forgotPasswordForm').style.display = 'block';
            document.getElementById('resetPasswordForm').style.display = 'none';
        }

        function showResetPasswordForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'none';
            document.getElementById('forgotPasswordForm').style.display = 'none';
            document.getElementById('resetPasswordForm').style.display = 'block';
        }

        function showLoginScreen() {
    console.log('Showing login screen...');
    hideAll();
    var loginScreen = document.getElementById('loginScreen');
    if (loginScreen) {
        loginScreen.style.display = 'block';
        console.log('Login screen displayed');
    } else {
        console.error('Login screen element not found!');
    }
    showLoginForm();
    // Add this line to setup the Enter key handlers
    setupLoginKeyHandlers();
}

        function loginUser() {
    var email = document.getElementById('loginEmail').value.trim();
    var password = document.getElementById('loginPassword').value;
    
    if (!email || !password) {
        alert('Please enter both email and password.');
        return;
    }
    
    console.log('Attempting login for:', email);
    
    // Show loading screen
    document.getElementById('loadingScreen').style.display = 'flex';
    document.getElementById('loadingScreen').style.opacity = '1';
    updateLoadingProgress(20, 'Authenticating...');
    
    hashPassword(password).then(function(hashedPassword) {
        updateLoadingProgress(40, 'Verifying credentials...');
        return fetch(SUPABASE_URL + '/rest/v1/users?email=eq.' + encodeURIComponent(email), {
            method: 'GET',
            headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
            }
        });
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Login failed: ' + response.status);
        }
        return response.json();
    })
    .then(function(users) {
        if (users.length === 0) {
            hideLoadingScreen();
            alert('No account found with this email. Please create an account first.');
            return;
        }
        
        var user = users[0];
        
        return hashPassword(password).then(function(hashedPassword) {
            if (user.password_hash === hashedPassword) {
                updateLoadingProgress(60, 'Login successful!');
                gameState.currentUser = user;
                gameState.isLoggedIn = true;
                
                localStorage.setItem('randofight_session', JSON.stringify({
                    user_id: user.user_id,
                    email: user.email,
                    username: user.username,
                    loginTime: Date.now()
                }));
                
                document.getElementById('usernameDisplay').textContent = user.username;
                console.log('Login successful for:', user.username);
                
                document.getElementById('loginEmail').value = '';
                document.getElementById('loginPassword').value = '';
                
                updateLoadingProgress(80, 'Loading your data...');
                loadFromSupabase();
                showTitleScreen();
            } else {
                hideLoadingScreen();
                alert('Incorrect password. Please try again.');
            }
        });
    })
    .catch(function(error) {
        console.error('Login error:', error);
        hideLoadingScreen();
        alert('Login failed. Please check your connection and try again.');
    });
}

        function logoutUser() {
    // Check if user is a guest
    if (gameState.currentUser && gameState.currentUser.isGuest) {
        if (confirm('You are playing as a guest. Your progress is only saved locally. Create an account to save your progress in the cloud?')) {
            showSignupFormWithData();
            return;
        }
    }
    
    // Clear all user data
    gameState.currentUser = null;
    gameState.isLoggedIn = false;
    gameState.fighters = [];
    gameState.currentFighter = null;
    gameState.diamonds = 0;
    gameState.fightCooldownEnd = 0;
    gameState.unlockedSlots = [true, false, false, false, false];
    gameState.currentSlotIndex = 0;
    gameState.currentBoss = null;
    gameState.dailyTasks = {
        lastReset: new Date().toDateString(),
        winsToday: 0,
        claimed: {
            win3: false,
            win5: false,
            win10: false,
            win20: false,
            win30: false
        }
    };
    
    // Clear ALL local storage data related to the game
    localStorage.removeItem('randofight_session');
    localStorage.removeItem('randofight_gamedata');
    localStorage.removeItem('randofight_user_id');
    localStorage.removeItem('randofight_referrer');
    localStorage.removeItem('reset_token_demo');
    localStorage.removeItem('reset_user_id');
    
    console.log('User logged out and all local data cleared');
    
    showLoginScreen();
}

        function signupUser() {
            var email = document.getElementById('signupEmail').value.trim();
            var password = document.getElementById('signupPassword').value;
            var username = document.getElementById('signupUsername').value.trim();
            
            if (!email || !password || !username) {
                alert('Please fill in all fields.');
                return;
            }
            
            if (password.length < 6) {
                alert('Password must be at least 6 characters long.');
                return;
            }
            
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            if (username.length < 3) {
                alert('Username must be at least 3 characters long.');
                return;
            }
            
            console.log('Attempting signup for:', email);
            
            // Store guest data before signup if applicable
            var guestData = null;
            if (gameState.currentUser && gameState.currentUser.isGuest) {
                guestData = {
                    fighters: gameState.fighters,
                    diamonds: gameState.diamonds,
                    fightCooldownEnd: gameState.fightCooldownEnd,
                    unlockedSlots: gameState.unlockedSlots
                };
                console.log('Storing guest data for transfer:', guestData);
            }
            
            fetch(SUPABASE_URL + '/rest/v1/users?email=eq.' + encodeURIComponent(email), {
                method: 'GET',
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                }
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(existingUsers) {
                if (existingUsers.length > 0) {
                    alert('An account with this email already exists. Please use a different email or login instead.');
                    return Promise.reject('Email exists');
                }
                
                return fetch(SUPABASE_URL + '/rest/v1/users?username=eq.' + encodeURIComponent(username), {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                    }
                });
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(existingUsernames) {
                if (existingUsernames.length > 0) {
                    alert('Username "' + username + '" is already taken. Please choose a different username.');
                    return Promise.reject('Username exists');
                }
                
                return hashPassword(password);
            })
            .then(function(hashedPassword) {
                var newUser = {
                    user_id: 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    email: email,
                    username: username,
                    password_hash: hashedPassword,
                    created_at: new Date().toISOString()
                };
                
                return fetch(SUPABASE_URL + '/rest/v1/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                    },
                    body: JSON.stringify(newUser)
                })
                .then(function(response) {
    if (response.ok) {
        // If we have guest data, transfer it to the new account
        if (guestData) {
            gameState.currentUser = newUser;
            gameState.isLoggedIn = true;
            gameState.fighters = guestData.fighters;
            gameState.diamonds = guestData.diamonds;
            gameState.fightCooldownEnd = guestData.fightCooldownEnd;
            gameState.unlockedSlots = guestData.unlockedSlots;
            
            // Save guest data to the cloud
            saveToSupabase();
            
            localStorage.setItem('randofight_session', JSON.stringify({
                user_id: newUser.user_id,
                email: newUser.email,
                username: newUser.username,
                loginTime: Date.now()
            }));
            
            alert('Account created successfully and your guest progress has been transferred to the cloud!');
            document.getElementById('usernameDisplay').textContent = newUser.username;
            
            // Clear form fields
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('signupUsername').value = '';
            
            // Show title screen - this will trigger the button fix
            showTitleScreen();
        } else {
            alert('Account created successfully! Please login with your new credentials.');
            showLoginForm();
            
            // Clear form fields
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('signupUsername').value = '';
        }
    } else {
        throw new Error('Signup failed: ' + response.status);
    }
});
            })
            .catch(function(error) {
                if (error !== 'Email exists' && error !== 'Username exists') {
                    console.error('Signup error:', error);
                    alert('Account creation failed. Please try again.');
                }
            });
        }

        function playAsGuest() {
            console.log('Starting guest mode...');
            
            // Set up guest mode
            gameState.currentUser = {
                user_id: 'guest_' + Date.now(),
                username: 'Guest Player',
                email: null,
                isGuest: true
            };
            gameState.isLoggedIn = false; // Keep as false to indicate guest mode
            
            // Load any existing guest data
            loadGameData();
            
            // Show title screen with guest indicator
            showTitleScreenGuest();
            
            console.log('Guest mode initialized');
        }

        function showTitleScreenGuest() {
            hideAll();
            document.getElementById('titleScreen').style.display = 'block';
            updateFighterSlots();
            updateDiamondDisplay();
            
            // Update the welcome message for guest mode
            var usernameElement = document.getElementById('usernameDisplay');
            if (usernameElement) {
                usernameElement.textContent = 'Guest Player';
            }
            
            // Change the cloud save message to local save for guests
            var cloudSaveMessage = document.querySelector('div[style*="background: rgba(34, 197, 94, 0.2)"]');
            if (cloudSaveMessage) {
                cloudSaveMessage.innerHTML = '<p style="color: #f59e0b; font-size: 0.9em; margin: 0;">‚ö†Ô∏è <strong>Playing as Guest:</strong> Your progress is saved locally. Create an account to sync across devices!</p>';
                cloudSaveMessage.style.background = 'rgba(245, 158, 11, 0.2)';
                cloudSaveMessage.style.borderColor = '#f59e0b';
            }
            
            // Find and update the logout button - try multiple selectors
            var logoutBtn = document.querySelector('button[onclick="logoutUser()"]') || 
                           document.querySelector('.btn-secondary[onclick="logoutUser()"]') ||
                           document.querySelector('button:contains("Logout")');
            
            // If we can't find it by onclick, find it by text content
            if (!logoutBtn) {
                var allButtons = document.querySelectorAll('button');
                for (var i = 0; i < allButtons.length; i++) {
                    if (allButtons[i].textContent.includes('Logout')) {
                        logoutBtn = allButtons[i];
                        break;
                    }
                }
            }
            
            if (logoutBtn) {
                console.log('Found logout button, updating for guest mode');
                logoutBtn.textContent = 'Create Account';
                // Remove the old onclick attribute and add new one
                logoutBtn.removeAttribute('onclick');
                logoutBtn.addEventListener('click', createAccountFromGuest);
                
                // Also update the attribute as backup
                logoutBtn.setAttribute('onclick', 'createAccountFromGuest()');
            } else {
                console.log('Could not find logout button to update');
            }
            
            // Initialize PayPal buttons when title screen is shown
            setTimeout(function() {
                initPayPalButtons();
            }, 100);
        }

        function createAccountFromGuest() {
            if (confirm('Creating an account will sync your current progress to the cloud. Continue?')) {
                showSignupFormWithData();
            }
        }

        function showSignupFormWithData() {
            showLoginScreen();
            showSignupForm();
            
            // Add a notice about data transfer
            var signupForm = document.getElementById('signupForm');
            if (signupForm) {
                // Remove any existing notices first
                var existingNotice = signupForm.querySelector('[style*="background: rgba(34, 197, 94"]');
                if (existingNotice) {
                    existingNotice.remove();
                }
                
                var notice = document.createElement('div');
                notice.innerHTML = '<div style="background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; border-radius: 5px; padding: 10px; margin-bottom: 15px;">' +
                    '<p style="color: #22c55e; font-size: 0.9em; margin: 0;">üì§ <strong>Data Transfer:</strong> Your current progress will be saved to your new account!</p>' +
                '</div>';
                signupForm.insertBefore(notice, signupForm.firstChild);
            }
        }

        function sendPasswordReset() {
            var email = document.getElementById('resetEmail').value.trim();
            
            if (!email) {
                alert('Please enter your email address.');
                return;
            }
            
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            console.log('Sending password reset for:', email);
            
            // Check if user exists
            fetch(SUPABASE_URL + '/rest/v1/users?email=eq.' + encodeURIComponent(email), {
                method: 'GET',
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                }
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(users) {
                if (users.length === 0) {
                    // Don't reveal if email exists or not for security
                    alert('If an account with this email exists, you will receive a password reset link shortly.');
                    return;
                }
                
                var user = users[0];
                
                // Generate reset token
                var resetToken = generateResetToken();
                var resetExpiry = new Date(Date.now() + 60 * 60 * 1000).toISOString(); // 1 hour from now
                
                // Store reset token in database
                return fetch(SUPABASE_URL + '/rest/v1/password_resets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                    },
                    body: JSON.stringify({
                        user_id: user.user_id,
                        reset_token: resetToken,
                        expires_at: resetExpiry,
                        created_at: new Date().toISOString()
                    })
                })
                .then(function(response) {
                    if (response.ok) {
                        // Wait a moment for EmailJS to be available, then try to send email
                        setTimeout(function() {
                            if (initEmailJS()) {
                                sendResetEmail(email, user.username, resetToken);
                            } else {
                                // Fallback to demo mode
                                console.log('EmailJS failed, falling back to demo mode');
                                localStorage.setItem('reset_token_demo', resetToken);
                                localStorage.setItem('reset_user_id', user.user_id);
                                
                                alert('EmailJS not available - Demo Mode:\n\nPassword reset link: \n' + window.location.origin + window.location.pathname + '?reset=' + resetToken + '\n\nCopy this link and paste it in your browser to reset your password.');
                            }
                        }, 2000);
                        
                        showLoginForm();
                        document.getElementById('resetEmail').value = '';
                    } else {
                        throw new Error('Failed to create reset token');
                    }
                });
            })
            .catch(function(error) {
                console.error('Password reset error:', error);
                alert('If an account with this email exists, you will receive a password reset link shortly.');
            });
        }

        function sendResetEmail(email, username, resetToken) {
            var resetLink = window.location.origin + window.location.pathname + '?reset=' + resetToken;
            
            console.log('Sending email to:', email);
            console.log('Reset link:', resetLink);
            
            var templateParams = {
                to_email: email,
                to_name: username,
                reset_link: resetLink,
                game_name: 'RandoFight',
                expiry_time: '1 hour'
            };
            
            console.log('Template parameters:', templateParams);
            
            emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, templateParams)
                .then(function(response) {
                    console.log('Email sent successfully:', response);
                    alert('Password reset instructions have been sent to your email address. Please check your inbox (and spam folder) for the reset link.');
                })
                .catch(function(error) {
                    console.error('EmailJS error:', error);
                    
                    // Check if it's a template/configuration issue
                    if (error.status === 422) {
                        console.error('Template error - check your EmailJS template configuration');
                        alert('Email template configuration error. Please check:\n\n1. Your EmailJS template exists\n2. Template uses {{to_email}} variable\n3. Email service is properly connected\n\nFalling back to demo mode...');
                    }
                    
                    // Fallback to demo mode if email fails
                    localStorage.setItem('reset_token_demo', resetToken);
                    
                    alert('Email service error - Demo Mode:\n\nPassword reset link: \n' + resetLink + '\n\nCopy this link and paste it in your browser to reset your password.');
                });
        }

        function generateResetToken() {
            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            var token = '';
            for (var i = 0; i < 32; i++) {
                token += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return token;
        }

        function resetPassword() {
            var newPassword = document.getElementById('newPassword').value;
            var confirmPassword = document.getElementById('confirmPassword').value;
            var resetToken = getResetTokenFromURL();
            
            if (!newPassword || !confirmPassword) {
                alert('Please fill in all fields.');
                return;
            }
            
            if (newPassword.length < 6) {
                alert('Password must be at least 6 characters long.');
                return;
            }
            
            if (newPassword !== confirmPassword) {
                alert('Passwords do not match.');
                return;
            }
            
            if (!resetToken) {
                alert('Invalid or missing reset token.');
                return;
            }
            
            console.log('Resetting password with token:', resetToken);
            
            // Verify reset token and get user
            fetch(SUPABASE_URL + '/rest/v1/password_resets?reset_token=eq.' + encodeURIComponent(resetToken), {
                method: 'GET',
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                }
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(resetTokens) {
                if (resetTokens.length === 0) {
                    alert('Invalid or expired reset token.');
                    return;
                }
                
                var resetRecord = resetTokens[0];
                var expiryTime = new Date(resetRecord.expires_at).getTime();
                
                if (Date.now() > expiryTime) {
                    alert('Reset token has expired. Please request a new password reset.');
                    return;
                }
                
                // Hash the new password
                return hashPassword(newPassword).then(function(hashedPassword) {
                    // Update user password
                    return fetch(SUPABASE_URL + '/rest/v1/users?user_id=eq.' + encodeURIComponent(resetRecord.user_id), {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                        },
                        body: JSON.stringify({
                            password_hash: hashedPassword
                        })
                    })
                    .then(function(response) {
                        if (response.ok) {
                            // Delete used reset token
                            return fetch(SUPABASE_URL + '/rest/v1/password_resets?reset_token=eq.' + encodeURIComponent(resetToken), {
                                method: 'DELETE',
                                headers: {
                                    'apikey': SUPABASE_ANON_KEY,
                                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                                }
                            });
                        } else {
                            throw new Error('Failed to update password');
                        }
                    })
                    .then(function() {
                        // Clear demo tokens
                        localStorage.removeItem('reset_token_demo');
                        localStorage.removeItem('reset_user_id');
                        
                        alert('Password updated successfully! You can now login with your new password.');
                        
                        // Clear URL parameter and redirect to clean login
                        window.history.replaceState({}, document.title, window.location.pathname);
                        showLoginForm();
                        
                        // Clear form
                        document.getElementById('newPassword').value = '';
                        document.getElementById('confirmPassword').value = '';
                    });
                });
            })
            .catch(function(error) {
                console.error('Password reset error:', error);
                alert('Failed to reset password. Please try again.');
            });
        }

        function checkForPasswordReset() {
            console.log('Checking for password reset...');
            
            // Check URL first
            var urlParams = new URLSearchParams(window.location.search);
            var tokenFromURL = urlParams.get('reset');
            console.log('URL reset token:', tokenFromURL);
            
            // Check localStorage
            var tokenFromDemo = localStorage.getItem('reset_token_demo');
            console.log('Demo token from localStorage:', tokenFromDemo);
            
            var resetToken = tokenFromURL || tokenFromDemo;
            
            if (resetToken) {
                console.log('Password reset token found:', resetToken, 'showing reset form');
                showResetPasswordForm();
                return true;
            } else {
                console.log('No reset token found');
                return false;
            }
        }

        // Add Enter key functionality for login form
function setupLoginKeyHandlers() {
    var loginEmail = document.getElementById('loginEmail');
    var loginPassword = document.getElementById('loginPassword');
    
    if (loginEmail) {
        loginEmail.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loginUser();
            }
        });
    }
    
    if (loginPassword) {
        loginPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loginUser();
            }
        });
    }
    
    // Also add for signup form
    var signupEmail = document.getElementById('signupEmail');
    var signupPassword = document.getElementById('signupPassword');
    var signupUsername = document.getElementById('signupUsername');
    
    if (signupEmail) {
        signupEmail.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                signupUser();
            }
        });
    }
    
    if (signupPassword) {
        signupPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                signupUser();
            }
        });
    }
    
    if (signupUsername) {
        signupUsername.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                signupUser();
            }
        });
    }
    
    // Add for password reset form
    var resetEmail = document.getElementById('resetEmail');
    
    if (resetEmail) {
        resetEmail.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendPasswordReset();
            }
        });
    }
}
        
        function getResetTokenFromURL() {
            var urlParams = new URLSearchParams(window.location.search);
            var tokenFromURL = urlParams.get('reset');
            
            if (!tokenFromURL) {
                var tokenFromDemo = localStorage.getItem('reset_token_demo');
                if (tokenFromDemo) {
                    console.log('Using demo reset token from localStorage');
                    return tokenFromDemo;
                }
            }
            
            return tokenFromURL;
        }

        // Game functions
        function saveToSupabase(retryCount) {
    // If user is a guest, save locally instead
    if (gameState.currentUser && gameState.currentUser.isGuest) {
        saveGameData();
        return;
    }
    
    if (retryCount === undefined) {
        retryCount = 0;
    }
    
    var userId = getUserId();
    var gameData = {
        user_id: userId,
        fighters: gameState.fighters,
        diamonds: gameState.diamonds,
        fight_cooldown_end: gameState.fightCooldownEnd,
        unlocked_slots: gameState.unlockedSlots,
        daily_tasks: gameState.dailyTasks, // Make sure this is included
        updated_at: new Date().toISOString()
    };

    console.log('Saving to Supabase via REST API (attempt ' + (retryCount + 1) + '):', gameData);
            
    // First, check if record exists
    fetch(SUPABASE_URL + '/rest/v1/game_data?user_id=eq.' + encodeURIComponent(userId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to check existing data: ' + response.status);
        }
        return response.json();
    })
    .then(function(existingData) {
        if (existingData && existingData.length > 0) {
            // Update existing record
            return fetch(SUPABASE_URL + '/rest/v1/game_data?user_id=eq.' + encodeURIComponent(userId), {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                },
                body: JSON.stringify(gameData)
            });
        } else {
            // Insert new record
            return fetch(SUPABASE_URL + '/rest/v1/game_data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                },
                body: JSON.stringify(gameData)
            });
        }
    })
    .then(function(response) {
        if (response.ok) {
            console.log('Saved to Supabase successfully!');
            hideCloudSaveError(); // Hide error popup if it was showing
            
            // Also save to localStorage as backup
            saveGameData();
            return true; // ADD THIS
        } else {
            console.error('Supabase save error:', response.status, response.statusText);
            return response.text().then(function(text) {
                console.error('Error details:', text);
                throw new Error('Save failed: ' + response.status);
            });
        }
    })
    .catch(function(e) {
        console.error('Save failed:', e);
        
        // Save to localStorage as fallback
        saveGameData();
        
        // Show error popup with retry option
        showCloudSaveError(retryCount);
    });
}

function showCloudSaveError(retryCount) {
    var existingPopup = document.getElementById('cloudSaveErrorPopup');
    if (existingPopup) {
        return; // Don't show multiple popups
    }
    
    var popupHTML = 
        '<div id="cloudSaveErrorPopup" style="position: fixed; top: 20px; right: 20px; background: #e74c3c; color: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 3000; max-width: 350px; animation: slideIn 0.3s ease;">' +
            '<div style="display: flex; align-items: start; gap: 15px;">' +
                '<div style="font-size: 2em;">‚ö†Ô∏è</div>' +
                '<div style="flex: 1;">' +
                    '<h4 style="margin: 0 0 10px 0; font-size: 1.1em;">Cloud Save Failed</h4>' +
                    '<p style="margin: 0 0 15px 0; font-size: 0.9em;">Unable to sync your progress to the cloud. Your data is saved locally, but may not be available on other devices.</p>' +
                    '<div style="display: flex; gap: 10px;">' +
                        '<button class="btn btn-primary" onclick="retryCloudSave(' + retryCount + ')" style="padding: 8px 16px; font-size: 0.9em;">Retry</button>' +
                        '<button class="btn" style="background: rgba(255,255,255,0.2); color: #fff; padding: 8px 16px; font-size: 0.9em;" onclick="hideCloudSaveError()">Dismiss</button>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>' +
        '<style>' +
            '@keyframes slideIn {' +
                'from { transform: translateX(400px); opacity: 0; }' +
                'to { transform: translateX(0); opacity: 1; }' +
            '}' +
        '</style>';
    
    document.body.insertAdjacentHTML('beforeend', popupHTML);
    
    // Auto-dismiss after 10 seconds if user doesn't interact
    setTimeout(function() {
        hideCloudSaveError();
    }, 10000);
}

function hideCloudSaveError() {
    var popup = document.getElementById('cloudSaveErrorPopup');
    if (popup) {
        popup.style.animation = 'slideOut 0.3s ease';
        setTimeout(function() {
            popup.remove();
        }, 300);
    }
}

function retryCloudSave(previousRetryCount) {
    hideCloudSaveError();
    
    var newRetryCount = previousRetryCount + 1;
    
    if (newRetryCount > 3) {
        alert('Unable to sync to cloud after multiple attempts. Your progress is saved locally. Please check your internet connection and try again later.');
        return;
    }
    
    saveToSupabase(newRetryCount);
}
        function loadFromSupabase() {
    if (gameState.currentUser && gameState.currentUser.isGuest) {
        updateLoadingProgress(50, 'Loading local data...');
        loadGameData();
        updateFighterSlots();
        updateDiamondDisplay();
        updateLoadingProgress(100, 'Ready!');
        setTimeout(hideLoadingScreen, 300);
        return;
    }
    
    var userId = getUserId();
    console.log('Loading from Supabase via REST API for user:', userId);
    
    updateLoadingProgress(20, 'Connecting to server...');
    
    // First check localStorage for comparison
    var localData = localStorage.getItem('randofight_gamedata');
    var localTimestamp = null;
    if (localData) {
        try {
            var parsed = JSON.parse(localData);
            localTimestamp = parsed.lastSaved || 0;
        } catch(e) {}
    }
    
    updateLoadingProgress(40, 'Fetching your data...');
    
    fetch(SUPABASE_URL + '/rest/v1/game_data?user_id=eq.' + encodeURIComponent(userId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Load failed: ' + response.status);
        }
        updateLoadingProgress(60, 'Processing data...');
        return response.json();
    })
    .then(function(data) {
    console.log('Raw Supabase response:', data);
    
    updateLoadingProgress(80, 'Loading characters...');
    
    if (data && data.length > 0) {
        var gameData = data[0];
        var cloudTimestamp = new Date(gameData.updated_at).getTime();
        
        // Compare timestamps - use newer data
        if (localTimestamp && localTimestamp > cloudTimestamp) {
            console.log('Local data is newer, using local data and syncing to cloud');
            loadGameData();
            saveToSupabase();
        } else {
            console.log('Loading data from Supabase:', gameData);
            gameState.fighters = gameData.fighters || [];
            gameState.diamonds = gameData.diamonds || 0;
            gameState.fightCooldownEnd = gameData.fight_cooldown_end || 0;
            gameState.unlockedSlots = gameData.unlocked_slots || [true, false, false, false, false];
            
            // Load daily tasks - IMPORTANT: Load before initializing
            if (gameData.daily_tasks) {
                gameState.dailyTasks = gameData.daily_tasks;
                console.log('Loaded daily tasks from cloud:', gameState.dailyTasks);
            }
            
            // Also save to localStorage
            saveGameData();
            console.log('Game loaded from cloud successfully!');
        }
    } else {
        console.log('No saved data found in Supabase - checking localStorage');
        loadGameData();
    }
    
    // Initialize daily tasks (will create if missing or reset if new day)
    initializeDailyTasks();
    
    updateLoadingProgress(100, 'Ready!');
    
    updateFighterSlots();
    updateDiamondDisplay();
    
    // Hide loading screen after a brief delay
    setTimeout(hideLoadingScreen, 300);
})
        }

        function saveGameData() {
    try {
        var gameData = JSON.stringify({
            fighters: gameState.fighters,
            diamonds: gameState.diamonds,
            fightCooldownEnd: gameState.fightCooldownEnd,
            unlockedSlots: gameState.unlockedSlots,
            dailyTasks: gameState.dailyTasks, // Add this line
            lastSaved: Date.now()
        });
        localStorage.setItem('randofight_gamedata', gameData);
        console.log('Game saved to localStorage');
    } catch (e) {
        console.log('Save failed:', e);
    }
}

        function loadGameData() {
    try {
        var gameData = localStorage.getItem('randofight_gamedata');
        if (gameData) {
            var data = JSON.parse(gameData);
            gameState.fighters = data.fighters || [];
            gameState.diamonds = data.diamonds || 0;
            gameState.fightCooldownEnd = data.fightCooldownEnd || 0;
            gameState.unlockedSlots = data.unlockedSlots || [true, false, false, false, false];
            gameState.dailyTasks = data.dailyTasks || {
                lastReset: new Date().toDateString(),
                winsToday: 0,
                claimed: {
                    win3: false,
                    win5: false,
                    win10: false,
                    win20: false,
                    win30: false
                }
            };
            console.log('Game loaded from localStorage');
        } else {
            console.log('No saved data found');
        }
    } catch (e) {
        console.log('Load failed:', e);
    }
}

        function hideAll() {
    var screens = ['loginScreen', 'titleScreen', 'creationScreen', 'fighterScreen', 'fightScreen'];
    for (var i = 0; i < screens.length; i++) {
        var screen = document.getElementById(screens[i]);
        if (screen) {
            screen.style.display = 'none';
        }
    }
}

        function updateDiamondDisplay() {
            var titleDiamonds = document.getElementById('titleDiamonds');
            if (titleDiamonds) {
                titleDiamonds.textContent = gameState.diamonds;
            }
            var diamondsDisplay = document.getElementById('diamonds');
            if (diamondsDisplay) {
                diamondsDisplay.textContent = gameState.diamonds;
            }
        }

        function showTitleScreen() {
    hideAll();
    document.getElementById('titleScreen').style.display = 'block';
    updateFighterSlots();
    updateDiamondDisplay();
    
    // Check for weekly prizes when entering title screen
    setTimeout(function() {
        checkWeeklyPrizes();
    }, 1000);
    
    // Initialize PayPal buttons when title screen is shown
    setTimeout(function() {
        initPayPalButtons();
    }, 100);
}

        function showCreationScreen() {
            hideAll();
            document.getElementById('creationScreen').style.display = 'block';
            document.getElementById('fighterName').value = '';
        }

        function showFighterScreen() {
    try {
        console.log('showFighterScreen called');
        console.log('Current fighter:', gameState.currentFighter);
        
        hideAll(); // This should hide titleScreen
        
        var fighterScreen = document.getElementById('fighterScreen');
        if (!fighterScreen) {
            throw new Error('Fighter screen element not found');
        }
        
        fighterScreen.style.display = 'block';
        console.log('Fighter screen display set to block');
        
        document.getElementById('globalBackBtn').style.display = 'block'; // Show back button
        
        updateFighterDisplay();
        console.log('Fighter display updated');
        
        updateFightStatus();
        console.log('Fight status updated');
        
        setTimeout(function() {
            initPayPalButtons();
        }, 100);
    } catch (error) {
        console.error('Error in showFighterScreen:', error);
        alert('Error displaying character screen: ' + error.message + '\nCheck console for details');
    }
}
function showGlobalLeaderboard() {
    var existingModal = document.getElementById('globalLeaderboardModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="globalLeaderboardModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">' +
                '<h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">Top Fighters</h2>' +
                '<div id="globalLeaderboardContent"></div>' +
                '<button class="btn btn-secondary" onclick="closeGlobalLeaderboard()" style="width: 100%; margin-top: 20px;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Update the leaderboard content
    var tempId = 'globalLeaderboardContent';
    var originalId = 'leaderboardContent';
    document.getElementById(tempId).id = originalId;
    updateLeaderboard();
    document.getElementById(originalId).id = tempId;
}
function initializeDailyTasks() {
    var today = new Date().toDateString();
    
    // If dailyTasks doesn't exist, initialize it
    if (!gameState.dailyTasks) {
        gameState.dailyTasks = {
            lastReset: today,
            winsToday: 0,
            claimed: {
                win3: false,
                win5: false,
                win10: false,
                win20: false,
                win30: false
            }
        };
        console.log('Initialized daily tasks for the first time');
        saveToSupabase();
        return;
    }
    
    // Check if it's a new day - only reset if the date has changed
    if (gameState.dailyTasks.lastReset !== today) {
        console.log('New day detected! Resetting daily tasks. Old date:', gameState.dailyTasks.lastReset, 'New date:', today);
        gameState.dailyTasks = {
            lastReset: today,
            winsToday: 0,
            claimed: {
                win3: false,
                win5: false,
                win10: false,
                win20: false,
                win30: false
            }
        };
        saveToSupabase();
    } else {
        console.log('Same day - keeping daily tasks progress:', gameState.dailyTasks);
    }
}
function incrementDailyWins() {
    initializeDailyTasks();
    gameState.dailyTasks.winsToday++;
    console.log('Incremented daily wins to:', gameState.dailyTasks.winsToday);
    saveToSupabase();
    saveGameData(); // Also save locally for immediate backup
}

function showDailyTasks() {
    initializeDailyTasks();
    
    var tasks = [
    { id: 'win3', wins: 3, reward: 2, label: 'Win 3 Fights' },
    { id: 'win5', wins: 5, reward: 6, label: 'Win 5 Fights' },
    { id: 'win10', wins: 10, reward: 10, label: 'Win 10 Fights' },
    { id: 'win20', wins: 20, reward: 20, label: 'Win 20 Fights' },
    { id: 'win30', wins: 30, reward: 30, label: 'Win 30 Fights' }
];
    
    var existingModal = document.getElementById('dailyTasksModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var tasksHTML = '';
    for (var i = 0; i < tasks.length; i++) {
        var task = tasks[i];
        var completed = gameState.dailyTasks.winsToday >= task.wins;
        var claimed = gameState.dailyTasks.claimed[task.id];
        
        var progressText = Math.min(gameState.dailyTasks.winsToday, task.wins) + '/' + task.wins;
        var statusColor = completed ? '#6bcf7f' : '#888';
        
        tasksHTML += 
            '<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">' +
                '<div style="flex: 1;">' +
                    '<div style="font-size: 1.1em; font-weight: bold; color: #fff; margin-bottom: 5px;">' + task.label + '</div>' +
                    '<div style="color: ' + statusColor + '; font-size: 0.9em;">' + progressText + ' ‚Ä¢ Reward: ' + task.reward + ' üíé</div>' +
                '</div>';
        
        if (claimed) {
            tasksHTML += '<div style="background: #6bcf7f; color: #fff; padding: 8px 16px; border-radius: 6px; font-weight: bold;">‚úì CLAIMED</div>';
        } else if (completed) {
            tasksHTML += '<button class="btn btn-primary" onclick="claimDailyTask(\'' + task.id + '\', ' + task.reward + ')" style="padding: 8px 20px;">CLAIM</button>';
        } else {
            tasksHTML += '<div style="color: #888; padding: 8px 16px;">Incomplete</div>';
        }
        
        tasksHTML += '</div>';
    }
    
    // Calculate time until reset
    var now = new Date();
    var tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    var msUntilReset = tomorrow - now;
    var hoursUntilReset = Math.floor(msUntilReset / (1000 * 60 * 60));
    var minutesUntilReset = Math.floor((msUntilReset % (1000 * 60 * 60)) / (1000 * 60));
    
    var modalHTML = 
        '<div id="dailyTasksModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">' +
                '<h2 style="color: #4ecdc4; text-align: center; margin-bottom: 10px;">üìÖ Daily Tasks</h2>' +
                '<p style="text-align: center; color: #888; font-size: 0.9em; margin-bottom: 20px;">Resets in ' + hoursUntilReset + 'h ' + minutesUntilReset + 'm</p>' +
                '<div style="margin-bottom: 20px;">' + tasksHTML + '</div>' +
                '<button class="btn btn-secondary" onclick="closeDailyTasks()" style="width: 100%;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function claimDailyTask(taskId, reward) {
    initializeDailyTasks();
    
    // Mark as claimed
    gameState.dailyTasks.claimed[taskId] = true;
    
    // Award diamonds
    gameState.diamonds += reward;
    
    // Save and update
    saveToSupabase();
    updateDiamondDisplay();
    
    // Close and reopen modal to refresh
    closeDailyTasks();
    showDailyTasks();
    
    // Show success message
    showLootMessage('‚úì Claimed ' + reward + ' üíé from daily task!');
}

function closeDailyTasks() {
    var modal = document.getElementById('dailyTasksModal');
    if (modal) {
        modal.remove();
    }
}
function closeGlobalLeaderboard() {
    var modal = document.getElementById('globalLeaderboardModal');
    if (modal) modal.remove();
}
function showLeaderboard() {
    showGlobalLeaderboard();
}

        function checkNameAvailability(name) {
            console.log('Checking if name "' + name + '" is available...');
            
            return fetch(SUPABASE_URL + '/rest/v1/game_data?select=fighters', {
                method: 'GET',
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
                }
            })
            .then(function(response) {
                if (!response.ok) {
                    throw new Error('Failed to check name availability: ' + response.status);
                }
                return response.json();
            })
            .then(function(allPlayers) {
                console.log('Checking name against', allPlayers.length, 'players...');
                
                for (var i = 0; i < allPlayers.length; i++) {
                    var playerData = allPlayers[i];
                    
                    if (!playerData.fighters || !Array.isArray(playerData.fighters)) {
                        continue;
                    }
                    
                    for (var j = 0; j < playerData.fighters.length; j++) {
                        var fighter = playerData.fighters[j];
                        
                        if (fighter && fighter.name && fighter.name.toLowerCase() === name.toLowerCase()) {
                            console.log('Name "' + name + '" is already taken');
                            return false;
                        }
                    }
                }
                
                console.log('Name "' + name + '" is available');
                return true;
            })
            .catch(function(error) {
                console.error('Error checking name availability:', error);
                for (var i = 0; i < gameState.fighters.length; i++) {
                    var fighter = gameState.fighters[i];
                    if (fighter && fighter.name && fighter.name.toLowerCase() === name.toLowerCase()) {
                        return false;
                    }
                }
                return true;
            });
        }
        function showPlayerProfile(playerName, userId) {
    // Show loading modal first
    var modalHTML = 
        '<div id="playerProfileModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">' +
                '<h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">Loading...</h2>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Fetch player data
    fetch(SUPABASE_URL + '/rest/v1/game_data?user_id=eq.' + encodeURIComponent(userId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        if (data.length === 0 || !data[0].fighters) {
            closePlayerProfile();
            alert('Unable to load player profile.');
            return;
        }
        
        // Find the fighter with matching name
        var fighter = null;
        for (var i = 0; i < data[0].fighters.length; i++) {
            if (data[0].fighters[i] && data[0].fighters[i].name === playerName) {
                fighter = data[0].fighters[i];
                break;
            }
        }
        
        if (!fighter) {
            closePlayerProfile();
            alert('Fighter not found.');
            return;
        }
        
        // Build profile display
        displayPlayerProfile(fighter);
    })
    .catch(function(error) {
        console.error('Error loading player profile:', error);
        closePlayerProfile();
        alert('Failed to load player profile.');
    });
}

function displayPlayerProfile(fighter) {
    // Calculate stats
    var strengthBonus = (fighter.stats.strength - 1) * 2;
    var toughnessChance = Math.min(40, (fighter.stats.toughness - 1) * 0.4);
    var dodgeChance = Math.min(35, (fighter.stats.agility - 1) * 0.35);
    var speedBonus = Math.min(50, (fighter.stats.speed - 1) * 0.5);
    var critChance = Math.min(50, (fighter.stats.luck - 1) * 0.5);
    
    // Calculate damage
    var baseDamage = 10;
    var weaponDamage = 0;
    var totalDefense = 0;
    
    if (fighter.equipment && fighter.equipment.weapon) {
        weaponDamage = fighter.equipment.weapon.power || 0;
    }
    
    var equipmentSlotNames = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
    for (var i = 0; i < equipmentSlotNames.length; i++) {
        var slot = equipmentSlotNames[i];
        var item = fighter.equipment[slot];
        if (item && item.statType === 'Defense') {
            totalDefense += item.power || 0;
        }
    }
    
    var totalDamage = baseDamage + strengthBonus + weaponDamage;
    var damageBonus = strengthBonus + weaponDamage;
    
    var specialDisplay = '';
    if (fighter.specialAttack && fighter.specialAttack.name) {
        var specialBaseDamage = fighter.level * 4 + 20;
        var specialStrengthBonus = (fighter.stats.strength - 1) * 2;
        
        if (specialStrengthBonus > 0) {
            specialDisplay = '<div class="stat-row"><span>Special Attack:</span> <span class="special">' + 
                fighter.specialAttack.name + ' (' + specialBaseDamage + ' + ' + specialStrengthBonus + ' damage)</span></div>';
        } else {
            specialDisplay = '<div class="stat-row"><span>Special Attack:</span> <span class="special">' + 
                fighter.specialAttack.name + ' (' + specialBaseDamage + ' damage)</span></div>';
        }
    } else {
        specialDisplay = '<div class="stat-row"><span>Special Attack:</span> <span style="color: #888;">Locked (Level 10 required)</span></div>';
    }
    
    // Build equipment display
    var equipmentHTML = '';
    var equipmentSlots = ['Weapon', 'Off-Hand', 'Helmet', 'Shoulders', 'Gloves', 'Chest', 'Greaves', 'Boots'];
    
    for (var i = 0; i < equipmentSlots.length; i++) {
        var slot = equipmentSlots[i];
        var slotKey = slot.toLowerCase().replace('-', '');
        var item = fighter.equipment[slotKey];
        
        var itemHTML = '<div class="equipment-slot">' +
            '<div class="slot-name">' + slot + '</div>' +
            '<div class="item-content">';
        
        if (item && item.statType) {
            var itemLevelText = item.itemLevel ? 'Lv.' + item.itemLevel + ' ' : '';
            itemHTML += '<div class="item-power">+' + item.power + ' ' + item.statType + '</div>' +
                '<div class="item-name ' + item.rarity + '" style="font-size: 0.75em;">' + 
                itemLevelText + item.name + '</div>';
        } else {
            itemHTML += '<div class="item-name">Empty</div>';
        }
        
        itemHTML += '</div></div>';
        equipmentHTML += itemHTML;
    }
    
    var profileHTML = 
        '<div id="playerProfileModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto;">' +
                '<h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">' + fighter.name + '\'s Profile</h2>' +
                
                '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">' +
                    '<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">' +
                        '<h3 style="color: #4ecdc4; margin-bottom: 10px; text-align: center;">Stats</h3>' +
                        '<div class="stat-row"><span>Level:</span> <span>' + fighter.level + '</span></div>' +
                        '<div class="stat-row"><span>Wins:</span> <span class="fighter-wins">' + fighter.wins + '</span></div>' +
                        '<div class="stat-row"><span>HP:</span> <span>' + fighter.maxHp + '</span></div>' +
                        '<div class="stat-row"><span>Damage:</span> <span style="color: #ff6b6b;">' + baseDamage + 
                            (damageBonus > 0 ? ' <span style="color: #6bcf7f;">(+' + damageBonus + ')</span>' : '') + '</span></div>' +
                        '<div class="stat-row"><span>Defense:</span> <span style="color: #74b9ff;">' + 
                            (totalDefense > 0 ? totalDefense + ' <span style="color: #888;">(-' + Math.min(60, totalDefense * 0.25).toFixed(1) + '% damage)</span>' : '0') + '</span></div>' +
                        '<hr style="margin: 10px 0; border-color: rgba(255,255,255,0.2);">' +
                        '<div class="stat-row"><span>Strength:</span> <span>' + fighter.stats.strength + '</span></div>' +
                        '<div class="stat-row"><span>Toughness:</span> <span>' + fighter.stats.toughness + '</span></div>' +
                        '<div class="stat-row"><span>Agility:</span> <span>' + fighter.stats.agility + '</span></div>' +
                        '<div class="stat-row"><span>Luck:</span> <span>' + fighter.stats.luck + '</span></div>' +
                        '<div class="stat-row"><span>Speed:</span> <span>' + fighter.stats.speed + '</span></div>' +
                        '<hr style="margin: 10px 0; border-color: rgba(255,255,255,0.2);">' +
                        specialDisplay +
                    '</div>' +
                    
                    '<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">' +
                        '<h3 style="color: #4ecdc4; margin-bottom: 10px; text-align: center;">Equipment</h3>' +
                        '<div class="equipment-grid" style="grid-template-columns: repeat(2, 1fr);">' +
                            equipmentHTML +
                        '</div>' +
                    '</div>' +
                '</div>' +
                
                '<button class="btn btn-secondary" onclick="closePlayerProfile()" style="width: 100%;">Close</button>' +
            '</div>' +
        '</div>';
    
    // Remove loading modal and show profile
    var existingModal = document.getElementById('playerProfileModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    document.body.insertAdjacentHTML('beforeend', profileHTML);
}

function closePlayerProfile() {
    var modal = document.getElementById('playerProfileModal');
    if (modal) {
        modal.remove();
    }
}
function updateWeeklyLeaderboardName(oldName, newName) {
    if (!gameState.currentUser || gameState.currentUser.isGuest) {
        return; // Don't update for guests
    }
    
    var userId = getUserId();
    var weekStart = getWeekStartDate();
    var weekStartStr = weekStart.toISOString().split('T')[0];
    
    // Update current week's entry if it exists
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?user_id=eq.' + userId + '&fighter_name=eq.' + encodeURIComponent(oldName) + '&week_start=eq.' + weekStartStr, {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        if (data.length > 0) {
            // Update the fighter name in the weekly scores
            return fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?id=eq.' + data[0].id, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
                },
                body: JSON.stringify({
                    fighter_name: newName,
                    updated_at: new Date().toISOString()
                })
            });
        }
    })
    .then(function() {
        console.log('Weekly leaderboard name updated');
    })
    .catch(function(error) {
        console.error('Error updating weekly leaderboard name:', error);
    });
}
        
function showRenameModal() {
    var fighter = gameState.currentFighter;
    if (!fighter) return;
    
    var existingModal = document.getElementById('renameModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="renameModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 400px; width: 90%; text-align: center;">' +
                '<h3 style="color: #4ecdc4; margin-bottom: 20px;">Rename Fighter</h3>' +
                '<p style="color: #ffd93d; margin-bottom: 10px;">Cost: 25 üíé</p>' +
                '<p style="color: #888; font-size: 0.9em; margin-bottom: 20px;">Current name: <span style="color: #fff;">' + fighter.name + '</span></p>' +
                '<div style="margin-bottom: 20px;">' +
                    '<input type="text" id="newFighterName" placeholder="Enter new name" maxlength="20" ' +
                    'style="width: 100%; padding: 10px; border: 1px solid #4ecdc4; border-radius: 4px; background: rgba(0,0,0,0.3); color: #fff; font-family: inherit;" ' +
                    'oninput="validateRenameInput()">' +
                    '<div id="renameError" style="color: #e74c3c; font-size: 0.9em; margin-top: 8px; min-height: 20px; display: none;"></div>' +
                    '<div style="margin-top: 10px; font-size: 0.85em; color: #888; text-align: left;">' +
                        '<p>‚Ä¢ 3-20 characters required</p>' +
                        '<p>‚Ä¢ Must contain at least one letter</p>' +
                        '<p>‚Ä¢ Inappropriate names will be blocked</p>' +
                    '</div>' +
                '</div>' +
                '<div style="display: flex; gap: 15px; justify-content: center;">' +
                    '<button class="btn btn-primary" onclick="confirmRename()">Rename (25 üíé)</button>' +
                    '<button class="btn btn-secondary" onclick="closeRenameModal()">Cancel</button>' +
                '</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Focus the input field
    setTimeout(function() {
        var input = document.getElementById('newFighterName');
        if (input) {
            input.focus();
        }
    }, 100);
}

function closeRenameModal() {
    var modal = document.getElementById('renameModal');
    if (modal) {
        modal.remove();
    }
}

function validateRenameInput() {
    var input = document.getElementById('newFighterName');
    var value = input.value;
    
    // Remove any numbers at the beginning
    value = value.replace(/^\d+/, '');
    
    // Limit to 20 characters
    if (value.length > 20) {
        value = value.substring(0, 20);
    }
    
    // Remove excessive special characters as they type
    value = value.replace(/[^a-zA-Z0-9\s\-_]/g, '');
    
    input.value = value;
}

function confirmRename() {
    var newName = document.getElementById('newFighterName').value.trim();
    var fighter = gameState.currentFighter;
    var errorDiv = document.getElementById('renameError');
    
    // Helper function to show error
    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        renameButton.disabled = false;
        renameButton.textContent = 'Rename (25 üíé)';
    }
    
    // Helper function to hide error
    function hideError() {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
    }
    
    // Get the rename button and disable it immediately
    var renameButton = document.querySelector('#renameModal .btn-primary');
    if (renameButton.disabled) {
        return; // Already processing
    }
    renameButton.disabled = true;
    renameButton.textContent = 'Processing...';
    
    hideError(); // Clear any previous errors
    
    if (!fighter) {
        return showError('No fighter selected!');
    }
    
    // Check if player has enough diamonds
    if (gameState.diamonds < 25) {
        return showError('You need 25 diamonds to rename your fighter! You currently have ' + gameState.diamonds + ' diamonds.');
    }
    
    // Validate new name (same validation as createFighter)
    if (!newName) {
        return showError('Please enter a new name!');
    }
    
    if (newName.length < 3) {
        return showError('Fighter name must be at least 3 characters long!');
    }
    
    if (newName.length > 20) {
        return showError('Fighter name must be 20 characters or less!');
    }
    
    // Check if it's the same name
    if (newName.toLowerCase() === fighter.name.toLowerCase()) {
        return showError('That\'s already your fighter\'s name!');
    }
    
    // List of inappropriate terms to block (same as createFighter)
    var inappropriateTerms = [
        // Sexual terms
        'sex', 'porn', 'xxx', 'nude', 'naked', 'penis', 'vagina', 'dick', 'cock', 'pussy',
        'boob', 'tit', 'ass', 'anal', 'oral', 'cum', 'jizz', 'fap', 'dildo', 'vibrator',
        'orgasm', 'erect', 'nipple', 'horny', 'slut', 'whore', 'bitch', 'hoe', 'pimp',
        
        // Racist terms and slurs
        'nigger', 'nigga', 'negro', 'coon', 'spic', 'wetback', 'beaner', 'chink', 
        'gook', 'jap', 'kike', 'jew', 'faggot', 'fag', 'dyke', 'tranny', 'shemale',
        'retard', 'midget', 'cripple', 'spastic', 'mongo',
        
        // Offensive terms
        'fuck', 'shit', 'piss', 'bastard', 'damn', 'hell', 'cunt', 'twat', 'douche',
        'rape', 'molest', 'pedo', 'nazi', 'hitler', 'isis', 'terrorist', 'suicide',
        'kill', 'murder', 'genocide', 'holocaust',
        
        // Drug references
        'cocaine', 'heroin', 'meth', 'crack', 'weed', 'marijuana', 'drug'
    ];
    
    // Check for inappropriate content
    var nameLower = newName.toLowerCase();
    var nameNoSpaces = nameLower.replace(/[^a-z0-9]/gi, '');
    
    for (var i = 0; i < inappropriateTerms.length; i++) {
        if (nameLower.includes(inappropriateTerms[i]) || nameNoSpaces.includes(inappropriateTerms[i])) {
            return showError('That name contains inappropriate content. Please choose a different name.');
        }
    }
    
    // Check for leetspeak variations
    var leetSpeakName = nameLower
        .replace(/0/g, 'o')
        .replace(/1/g, 'i')
        .replace(/3/g, 'e')
        .replace(/4/g, 'a')
        .replace(/5/g, 's')
        .replace(/7/g, 't')
        .replace(/@/g, 'a')
        .replace(/\$/g, 's');
    
    for (var i = 0; i < inappropriateTerms.length; i++) {
        if (leetSpeakName.includes(inappropriateTerms[i])) {
            return showError('That name contains inappropriate content. Please choose a different name.');
        }
    }
    
    // Check for all numbers or all special characters
    if (!/[a-zA-Z]/.test(newName)) {
        return showError('Fighter name must contain at least one letter!');
    }
    
    // Check for excessive special characters
    var specialCharCount = (newName.match(/[^a-zA-Z0-9\s]/g) || []).length;
    if (specialCharCount > 3) {
        return showError('Fighter name can only contain up to 3 special characters!');
    }
    
    // Check for spam patterns
    if (/(.)\1{4,}/.test(newName)) {
        return showError('Fighter name cannot contain more than 4 repeated characters in a row!');
    }
    
    // Check name availability
    checkNameAvailability(newName)
        .then(function(isAvailable) {
            if (!isAvailable) {
                return showError('Fighter name "' + newName + '" is already taken. Please choose a different name.');
            }
            
            // All validations passed - perform the rename
            var oldName = fighter.name;
            fighter.name = newName;
            gameState.diamonds -= 25;

            // Update weekly leaderboard entry
            updateWeeklyLeaderboardName(oldName, newName);

            // Save changes
            saveToSupabase();
            updateDiamondDisplay();
            updateFighterDisplay();

            // Close modal and show success
            closeRenameModal();
            alert('Fighter renamed from "' + oldName + '" to "' + newName + '"!');
        })
        .catch(function(error) {
            console.error('Error checking name availability:', error);
            showError('Unable to verify name availability. Please try again.');
        });
}
function showWeeklyTournamentFromFighter() {
    showWeeklyTournament();
}
        // Weekly Leaderboard Functions
function getWeekStartDate() {
    var now = new Date();
    var dayOfWeek = now.getUTCDay();
    var daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    var weekStart = new Date(now);
    weekStart.setUTCDate(now.getUTCDate() - daysToMonday);
    weekStart.setUTCHours(0, 0, 0, 0);
    return weekStart;
}

function getWeekEndDate() {
    var weekStart = getWeekStartDate();
    var weekEnd = new Date(weekStart);
    weekEnd.setUTCDate(weekStart.getUTCDate() + 6);
    weekEnd.setUTCHours(23, 59, 59, 999);
    return weekEnd;
}

function getTimeUntilReset() {
    var now = new Date();
    var weekEnd = getWeekEndDate();
    var timeLeft = weekEnd.getTime() - now.getTime();
    
    var days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    var hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    var minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
    
    return days + 'd ' + hours + 'h ' + minutes + 'm';
}

function updateWeeklyLeaderboard() {
    var content = document.getElementById('weeklyLeaderboardContent');
    if (!content) return;
    
    content.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Loading weekly leaderboard...</div>';
    
    var weekStart = getWeekStartDate();
    var weekStartStr = weekStart.toISOString().split('T')[0];
    
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?week_start=eq.' + weekStartStr + '&order=wins.desc', {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to fetch weekly leaderboard');
        }
        return response.json();
    })
    .then(function(weeklyScores) {
        var html = '<div style="text-align: center; margin-bottom: 15px;">' +
            '<div style="color: #ffd93d; font-size: 0.9em;">‚è±Ô∏è Resets in: <strong>' + getTimeUntilReset() + '</strong></div>' +
            '<div style="color: #888; font-size: 0.8em; margin-top: 5px;">Prizes will be awarded when timer expires</div>' +
            '</div>';
        
        if (weeklyScores.length === 0) {
            html += '<div style="text-align: center; padding: 20px; color: #888;">No battles yet this week!</div>';
        } else {
            var userId = getUserId();
            var displayCount = Math.min(20, weeklyScores.length);
            
            for (var i = 0; i < displayCount; i++) {
                var entry = weeklyScores[i];
                var rank = i + 1;
                
                var prizeText = '';
                if (rank === 1) prizeText = ' ü•á';
                else if (rank === 2) prizeText = ' ü•à';
                else if (rank === 3) prizeText = ' ü•â';
                
                var isCurrentUser = entry.user_id === userId;
                var highlightStyle = isCurrentUser ? ' style="background: rgba(78, 205, 196, 0.1); border-radius: 5px;"' : '';
                var yourFighterTag = isCurrentUser ? ' <span style="color: #4ecdc4; font-size: 0.8em;">(You)</span>' : '';
                
                html += '<div class="leaderboard-entry"' + highlightStyle + '>' +
                    '<span>' + rank + '. ' + entry.fighter_name + yourFighterTag + prizeText + '</span>' +
                    '<span>' + entry.wins + ' wins</span>' +
                    '</div>';
            }
        }
        
        content.innerHTML = html;
    })
    .catch(function(error) {
        console.error('Weekly leaderboard error:', error);
        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Failed to load weekly leaderboard</div>';
    });
}

// Function to track weekly wins (call this when a fighter wins)
function incrementWeeklyWins(fighter) {
    var weekStart = getWeekStartDate().toISOString();
    
    // Reset weekly wins if it's a new week
    if (!fighter.weeklyResetDate || fighter.weeklyResetDate !== weekStart) {
        fighter.weeklyWins = 0;
        fighter.weeklyResetDate = weekStart;
    }
    
    fighter.weeklyWins = (fighter.weeklyWins || 0) + 1;
}

// Function to check and claim weekly prizes (call on login)
function checkAndClaimWeeklyPrizes() {
    // This would need to track last claim date and compare rankings
    // Implementation depends on your backend setup
}

                function showWeeklyTournament() {
    var existingModal = document.getElementById('weeklyTournamentModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="weeklyTournamentModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; border: 2px solid #ffd93d; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">' +
                '<h2 style="color: #ffd93d; text-align: center; margin-bottom: 20px;">üèÜ Weekly Tournament</h2>' +
                '<div id="weeklyLeaderboardContent"></div>' +
                '<button class="btn btn-secondary" onclick="closeWeeklyTournament()" style="width: 100%; margin-top: 20px;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Update the weekly leaderboard
    updateWeeklyLeaderboard();
}

function closeWeeklyTournament() {
    var modal = document.getElementById('weeklyTournamentModal');
    if (modal) modal.remove();
}

        // Function to create special attack modal
function showSpecialAttackModal(fighterName, attackName) {
    var existingModal = document.getElementById('specialAttackModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="specialAttackModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 3px solid #ffd93d; max-width: 400px; text-align: center;">' +
                '<h2 style="color: #ffd93d; margin-bottom: 20px; font-size: 1.8em;">üéâ LEVEL 10! üéâ</h2>' +
                '<p style="color: #fff; font-size: 1.2em; margin-bottom: 15px;">' + fighterName + ' reached <span style="color: #ffd93d;">Level 10</span>!</p>' +
                '<p style="color: #fff; font-size: 1.1em; margin-bottom: 25px;">Learned the special attack:</p>' +
                '<p style="color: #ff6b6b; font-size: 1.5em; font-weight: bold; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">‚ú® ' + attackName + ' ‚ú®</p>' +
                '<button class="btn" style="background: #4ecdc4; color: #fff; padding: 12px 40px; font-size: 1.1em;" onclick="closeSpecialAttackModal()">Awesome!</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeSpecialAttackModal() {
    var modal = document.getElementById('specialAttackModal');
    if (modal) {
        modal.remove();
    }
}

// Track weekly wins in database
function saveWeeklyWin(fighterName) {
    if (!gameState.currentUser || gameState.currentUser.isGuest) {
        return;
    }
    
    var weekStart = getWeekStartDate();
    var weekStartStr = weekStart.toISOString().split('T')[0];
    var userId = getUserId();
    
    // Check if this user already has fighters in THIS week's tournament
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?user_id=eq.' + userId + '&week_start=eq.' + weekStartStr, {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(allUserFighters) {
        // Find if current fighter exists for THIS week
        var currentFighterEntry = null;
        for (var i = 0; i < allUserFighters.length; i++) {
            if (allUserFighters[i].fighter_name === fighterName && 
                allUserFighters[i].week_start === weekStartStr) {
                currentFighterEntry = allUserFighters[i];
                break;
            }
        }
        
        if (currentFighterEntry) {
            // Update existing record for this week
            var currentWins = currentFighterEntry.wins || 0;
            var newWins = currentWins + 1;
            
            return fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?id=eq.' + currentFighterEntry.id, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
                },
                body: JSON.stringify({
                    wins: newWins,
                    updated_at: new Date().toISOString()
                })
            }).then(function() {
                // Check if this fighter should be the only one representing the user
                removeOtherWeeklyFighters(userId, weekStartStr, fighterName);
            });
        } else {
            // Create new record for this week - starts at 1 win
            return fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
                },
                body: JSON.stringify({
                    user_id: userId,
                    fighter_name: fighterName,
                    week_start: weekStartStr,
                    wins: 1  // Start fresh at 1 for new week
                })
            }).then(function() {
                removeOtherWeeklyFighters(userId, weekStartStr, fighterName);
            });
        }
    })
    .then(function(response) {
        console.log('Weekly win tracked successfully');
    })
    .catch(function(error) {
        console.error('Error tracking weekly win:', error);
    });
}

function removeOtherWeeklyFighters(userId, weekStartStr, keepFighterName) {
    // Get all fighters for this user this week
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?user_id=eq.' + userId + '&week_start=eq.' + weekStartStr, {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(allFighters) {
        // Find the best fighter
        var bestFighter = null;
        var bestWins = 0;
        
        for (var i = 0; i < allFighters.length; i++) {
            if (allFighters[i].wins > bestWins) {
                bestWins = allFighters[i].wins;
                bestFighter = allFighters[i];
            }
        }
        
        // Delete all fighters except the best one
        var deletePromises = [];
        for (var i = 0; i < allFighters.length; i++) {
            if (allFighters[i].fighter_name !== bestFighter.fighter_name) {
                deletePromises.push(
                    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?id=eq.' + allFighters[i].id, {
                        method: 'DELETE',
                        headers: {
                            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
                        }
                    })
                );
            }
        }
        
        return Promise.all(deletePromises);
    })
    .then(function() {
        console.log('Removed lower-ranked fighters from weekly tournament');
    })
    .catch(function(error) {
        console.error('Error removing other fighters:', error);
    });
}

// Check and claim prizes on login
function checkWeeklyPrizes() {
    if (!gameState.currentUser || gameState.currentUser.isGuest) {
        return;
    }
    
    var userId = getUserId();
    var lastWeekStart = new Date();
    lastWeekStart.setDate(lastWeekStart.getDate() - 7);
    var lastWeekStartStr = lastWeekStart.toISOString().split('T')[0];
    
    // Get last week's scores for this user
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?user_id=eq.' + userId + '&week_start=eq.' + lastWeekStartStr + '&prize_claimed=eq.0', {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(userScores) {
        if (userScores.length === 0) return;
        
        // Get all scores for last week to determine rankings
        return fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?week_start=eq.' + lastWeekStartStr + '&order=wins.desc', {
            method: 'GET',
            headers: {
                'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
            }
        })
        .then(function(response) {
            return response.json();
        })
        .then(function(allScores) {
            var totalPrizesToClaim = 0;
            var fighterRanks = [];
            var bestRankForAccount = 999; // Track the best rank across all fighters
            
            // Calculate rank for each user's fighter
            for (var i = 0; i < userScores.length; i++) {
                var userScore = userScores[i];
                var rank = 1;
                
                for (var j = 0; j < allScores.length; j++) {
                    if (allScores[j].fighter_name === userScore.fighter_name) {
                        rank = j + 1;
                        break;
                    }
                }
                
                // Track the best rank
                if (rank < bestRankForAccount) {
                    bestRankForAccount = rank;
                }
                
                fighterRanks.push({
                    name: userScore.fighter_name,
                    rank: rank,
                    scoreId: userScore.id,
                    wins: userScore.wins
                });
            }
            
            // Award prize based on BEST rank only (not for each fighter)
            var prizeAmount = 0;
            if (bestRankForAccount === 1) prizeAmount = 300;  // Changed from 100
            else if (bestRankForAccount === 2) prizeAmount = 150;  // Changed from 50
            else if (bestRankForAccount === 3) prizeAmount = 75;  // Changed from 25
            else if (bestRankForAccount >= 4 && bestRankForAccount <= 10) prizeAmount = 30;  // Changed from 10
                        
            if (prizeAmount > 0) {
                // Award diamonds only once
                gameState.diamonds += prizeAmount;
                saveToSupabase();
                updateDiamondDisplay();
                
                // Mark all user's entries as claimed with their respective ranks
                var claimPromises = fighterRanks.map(function(fighter) {
                    return fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?id=eq.' + fighter.scoreId, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
                        },
                        body: JSON.stringify({
                            prize_claimed: fighter.rank === bestRankForAccount ? prizeAmount : 0, // Only mark the actual prize on best rank
                            rank: fighter.rank
                        })
                    });
                });
                
                Promise.all(claimPromises).then(function() {
                    // Show prize notification
                    var message = 'üéâ Weekly Tournament Prizes Claimed! üéâ\n\n';
                    
                    // Sort fighters by rank
                    fighterRanks.sort(function(a, b) { return a.rank - b.rank; });
                    
                    // Find the winning fighter
                    var winningFighter = fighterRanks.find(function(f) { return f.rank === bestRankForAccount; });
                    var medal = bestRankForAccount === 1 ? 'ü•á' : bestRankForAccount === 2 ? 'ü•à' : bestRankForAccount === 3 ? 'ü•â' : 'üèÖ';
                    
                    message += medal + ' Best rank: #' + bestRankForAccount + ' (' + winningFighter.name + ')\n';
                    message += 'Prize: +' + prizeAmount + ' üíé\n\n';
                    
                    // List other fighters if any
                    if (fighterRanks.length > 1) {
                        message += 'Other fighters:\n';
                        for (var i = 0; i < fighterRanks.length; i++) {
                            var f = fighterRanks[i];
                            if (f.rank !== bestRankForAccount) {
                                message += '‚Ä¢ ' + f.name + ' (Rank #' + f.rank + ', ' + f.wins + ' wins)\n';
                            }
                        }
                    }
                    
                    alert(message);
                });
            }
        });
    })
    .catch(function(error) {
        console.error('Error checking weekly prizes:', error);
    });
}

// Updated weekly leaderboard function to use database
function updateWeeklyLeaderboard() {
    var content = document.getElementById('weeklyLeaderboardContent');
    if (!content) return;
    
    content.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Loading weekly leaderboard...</div>';
    
    var weekStart = getWeekStartDate();
    var weekStartStr = weekStart.toISOString().split('T')[0];
    
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/weekly_scores?week_start=eq.' + weekStartStr + '&order=wins.desc', {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to fetch weekly leaderboard');
        }
        return response.json();
    })
    .then(function(weeklyScores) {
        var html = '<div style="text-align: center; margin-bottom: 15px;">' +
            '<div style="color: #ffd93d; font-size: 0.9em;">‚è±Ô∏è Resets in: <strong>' + getTimeUntilReset() + '</strong></div>' +
            '<div style="color: #888; font-size: 0.8em; margin-top: 5px;">Prizes awarded when timer expires</div>' +
            '</div>';
        
        if (weeklyScores.length === 0) {
            html += '<div style="text-align: center; padding: 20px; color: #888;">No battles yet this week!</div>';
        } else {
            var userId = getUserId();
            var displayCount = Math.min(20, weeklyScores.length);
            
            for (var i = 0; i < displayCount; i++) {
                var entry = weeklyScores[i];
                var rank = i + 1;
                
                var prizeText = '';
                if (rank === 1) prizeText = ' (300üíé)';  // Changed from 100üíé
                else if (rank === 2) prizeText = ' (150üíé)';  // Changed from 50üíé
                else if (rank === 3) prizeText = ' (75üíé)';  // Changed from 25üíé
                else if (rank >= 4 && rank <= 10) prizeText = ' (30üíé)';  // Changed from 10üíé
                
                var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank + '.';
                
                var isCurrentUser = entry.user_id === userId;
                var highlightStyle = isCurrentUser ? ' style="background: rgba(78, 205, 196, 0.1); border-radius: 5px;"' : '';
                var yourFighterTag = isCurrentUser ? ' <span style="color: #4ecdc4; font-size: 0.8em;">(You)</span>' : '';
                
                var nameClickable = entry.user_id ? 
    '<span style="cursor: pointer; text-decoration: underline;" onclick="showPlayerProfile(\'' + entry.fighter_name.replace(/'/g, "\\'") + '\', \'' + entry.user_id + '\')">' + entry.fighter_name + '</span>' : 
    entry.fighter_name;

html += '<div class="leaderboard-entry"' + highlightStyle + '>' +
    '<span>' + medal + ' ' + nameClickable + yourFighterTag + prizeText + '</span>' +
    '<span>' + entry.wins + ' wins</span>' +
    '</div>';
            }
        }
        
        content.innerHTML = html;
    })
    .catch(function(error) {
        console.error('Weekly leaderboard error:', error);
        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Failed to load weekly leaderboard</div>';
    });
}

        
        function createFighter() {
    var name = document.getElementById('fighterName').value.trim();
    var errorDiv = document.getElementById('nameError');
    
    // Helper function to show error
    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        return;
    }
    
    // Helper function to hide error
    function hideError() {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
    }
    
    hideError(); // Clear any previous errors
    
    if (!name) {
        return showError('Please enter a fighter name!');
    }
    
    // Check name length
    if (name.length < 3) {
        return showError('Fighter name must be at least 3 characters long!');
    }
    
    if (name.length > 20) {
        return showError('Fighter name must be 20 characters or less!');
    }
    
    // List of inappropriate terms to block (comprehensive list)
    var inappropriateTerms = [
        // Sexual terms
        'sex', 'porn', 'xxx', 'nude', 'naked', 'penis', 'vagina', 'dick', 'cock', 'pussy',
        'boob', 'tit', 'ass', 'anal', 'oral', 'cum', 'jizz', 'fap', 'dildo', 'vibrator',
        'orgasm', 'erect', 'nipple', 'horny', 'slut', 'whore', 'bitch', 'hoe', 'pimp',
        
        // Racist terms and slurs
        'nigger', 'nigga', 'negro', 'coon', 'spic', 'wetback', 'beaner', 'chink', 
        'gook', 'jap', 'kike', 'jew', 'faggot', 'fag', 'dyke', 'tranny', 'shemale',
        'retard', 'midget', 'cripple', 'spastic', 'mongo',
        
        // Offensive terms
        'fuck', 'shit', 'piss', 'bastard', 'damn', 'hell', 'cunt', 'twat', 'douche',
        'rape', 'molest', 'pedo', 'nazi', 'hitler', 'isis', 'terrorist', 'suicide',
        'kill', 'murder', 'genocide', 'holocaust',
        
        // Drug references
        'cocaine', 'heroin', 'meth', 'crack', 'weed', 'marijuana', 'drug'
    ];
    
    // Check for inappropriate content (case-insensitive)
    var nameLower = name.toLowerCase();
    var nameNoSpaces = nameLower.replace(/[^a-z0-9]/gi, ''); // Remove special chars and spaces
    
    for (var i = 0; i < inappropriateTerms.length; i++) {
        if (nameLower.includes(inappropriateTerms[i]) || nameNoSpaces.includes(inappropriateTerms[i])) {
            return showError('That name contains inappropriate content. Please choose a different name.');
        }
    }
    
    // Check for leetspeak variations
    var leetSpeakName = nameLower
        .replace(/0/g, 'o')
        .replace(/1/g, 'i')
        .replace(/3/g, 'e')
        .replace(/4/g, 'a')
        .replace(/5/g, 's')
        .replace(/7/g, 't')
        .replace(/@/g, 'a')
        .replace(/\$/g, 's');
    
    for (var i = 0; i < inappropriateTerms.length; i++) {
        if (leetSpeakName.includes(inappropriateTerms[i])) {
            return showError('That name contains inappropriate content. Please choose a different name.');
        }
    }
    
    // Check for all numbers or all special characters
    if (!/[a-zA-Z]/.test(name)) {
        return showError('Fighter name must contain at least one letter!');
    }
    
    // Check for excessive special characters
    var specialCharCount = (name.match(/[^a-zA-Z0-9\s]/g) || []).length;
    if (specialCharCount > 3) {
        return showError('Fighter name can only contain up to 3 special characters!');
    }
    
    // Check for spam patterns (repeating characters)
    if (/(.)\1{4,}/.test(name)) {
        return showError('Fighter name cannot contain more than 4 repeated characters in a row!');
    }
    
    // Check name availability (existing functionality)
    checkNameAvailability(name)
        .then(function(isAvailable) {
            if (!isAvailable) {
                return showError('Fighter name "' + name + '" is already taken. Please choose a different name.');
            }
            
            // All validations passed - create the fighter
            var fighter = {
    name: name,
    birthplace: 'Unknown',
    level: 1,
    exp: 0,
    expRequired: 100,
    hp: 100,
    maxHp: 100,
    wins: 0,
    lossStreak: 0,
    totalFights: 0,
    recentOpponents: [],
    stats: { strength: 1, toughness: 1, agility: 1, luck: 1, speed: 1 },
    unallocatedStats: 0,
    specialAttack: null,
    equipment: {
        weapon: { name: 'Wooden Stick', type: 'weapon', slot: 'weapon', power: 5, level: 1, itemLevel: 1, rarity: 'common', statType: 'Damage' },
        offHand: null, helmet: null, shoulders: null, gloves: null, chest: null, greaves: null, boots: null
    }
};

            gameState.fighters[gameState.currentSlotIndex] = fighter;
            
            var isFirstFighter = gameState.fighters.filter(function(f) { return f !== null && f !== undefined; }).length === 1;
            if (isFirstFighter && gameState.diamonds === 0) {
                gameState.diamonds = 10;
                alert('Welcome to RandoFight! You have received 10 free diamonds to get you started!');
            }
            
            saveToSupabase();
            gameState.currentFighter = fighter;
            
            // Process referral if this is first fighter AND user is not a guest
if (isFirstFighter && gameState.currentUser && !gameState.currentUser.isGuest) {
    var userId = getUserId();
    processReferral(userId);
    
    // Give the new user their 50 diamonds immediately
    setTimeout(function() {
        var referrerId = localStorage.getItem('randofight_referrer');
        if (referrerId) {
            console.log('New user receiving referral bonus');
            gameState.diamonds += 50;
            updateDiamondDisplay();
            saveToSupabase();
            localStorage.removeItem('randofight_referrer');
            
            alert('üéâ Welcome bonus! You received 50 diamonds for using a referral link! üíé\n\nYour friend can claim their reward from the Referral menu.');
        }
    }, 1000);
}
            
            showFighterScreen();
        })
        .catch(function(error) {
            console.error('Error checking name availability:', error);
            showError('Unable to verify name availability. Please try again.');
        });
}
        function validateFighterNameInput() {
    var input = document.getElementById('fighterName');
    var value = input.value;
    
    // Remove any numbers at the beginning
    value = value.replace(/^\d+/, '');
    
    // Limit to 20 characters
    if (value.length > 20) {
        value = value.substring(0, 20);
    }
    
    // Remove excessive special characters as they type
    value = value.replace(/[^a-zA-Z0-9\s\-_]/g, '');
    
    input.value = value;
}

        function selectFighter(slotIndex) {
    console.log('selectFighter called with index:', slotIndex);
    console.log('Unlocked slots:', gameState.unlockedSlots);
    console.log('Fighter at slot:', gameState.fighters[slotIndex]);
    
    if (!gameState.unlockedSlots[slotIndex]) {
        console.log('Slot not unlocked');
        return;
    }
    
    if (gameState.fighters[slotIndex]) {
        gameState.currentFighter = gameState.fighters[slotIndex];
        console.log('Current fighter set to:', gameState.currentFighter.name);
        console.log('About to call showFighterScreen');
        showFighterScreen();
    } else {
        gameState.currentSlotIndex = slotIndex;
        console.log('No fighter in slot, showing creation screen');
        showCreationScreen();
    }
}

        function purchaseSlot(slotIndex) {
            if (gameState.unlockedSlots[slotIndex]) {
                return;
            }
            
            if (gameState.diamonds < 200) {
                alert('You need 200 diamonds to unlock this slot! You currently have ' + gameState.diamonds + ' diamonds.');
                return;
            }
            
            gameState.diamonds -= 200;
            gameState.unlockedSlots[slotIndex] = true;
            updateDiamondDisplay();
            updateFighterSlots();
            saveToSupabase();
            alert('Fighter slot ' + (slotIndex + 1) + ' unlocked!');
        }

        function updateFighterSlots() {
            for (var i = 0; i < 5; i++) {
                var slotContainer = document.getElementById('slot-container-' + i);
                if (!slotContainer) continue;

                var fighter = gameState.fighters[i];
                slotContainer.innerHTML = '';
                slotContainer.className = 'fighter-slot';
                
                var slotNumber = document.createElement('div');
                slotNumber.className = 'slot-number';
                slotNumber.textContent = 'Slot ' + (i + 1);
                slotContainer.appendChild(slotNumber);
                
                if (fighter) {
                    var fighterContent = document.createElement('div');
                    fighterContent.innerHTML = 
                        '<div class="fighter-name">' + fighter.name + '</div>' +
                        '<div class="fighter-level">Level ' + fighter.level + '</div>' +
                        '<div class="fighter-wins">' + fighter.wins + ' wins</div>';
                    slotContainer.appendChild(fighterContent);
                    slotContainer.onclick = function(index) {
                        return function() { selectFighter(index); };
                    }(i);
                } else if (gameState.unlockedSlots[i]) {
                    var emptyContent = document.createElement('div');
                    emptyContent.innerHTML = 
                        '<div class="fighter-name">Empty Slot</div>' +
                        '<div>Click to create fighter</div>';
                    slotContainer.appendChild(emptyContent);
                    slotContainer.onclick = function(index) {
                        return function() { selectFighter(index); };
                    }(i);
                } else {
                    slotContainer.classList.add('locked');
                    var lockedContent = document.createElement('div');
                    lockedContent.innerHTML = 'Purchase this slot for 200 üíé';
                    slotContainer.appendChild(lockedContent);
                    slotContainer.onclick = function(index) {
                        return function() { purchaseSlot(index); };
                    }(i);
                }
            }
        }

        function deleteFighter() {
            if (!gameState.currentFighter) {
                alert('No fighter selected to delete!');
                return;
            }
            
            var fighterName = gameState.currentFighter.name;
            createDeleteModal(fighterName);
        }

        function createDeleteModal(fighterName) {
            var existingModal = document.getElementById('deleteModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            var modalHTML = 
                '<div id="deleteModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000;">' +
                    '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #e74c3c; max-width: 400px; text-align: center;">' +
                        '<h3 style="color: #e74c3c; margin-bottom: 20px;">Delete Fighter</h3>' +
                        '<p style="margin-bottom: 20px;">Are you sure you want to delete <span style="color: #4ecdc4; font-weight: bold;">' + fighterName + '</span>?</p>' +
                        '<p style="color: #888; font-size: 0.9em; margin-bottom: 25px;">This action cannot be undone!</p>' +
                        '<div style="display: flex; gap: 15px; justify-content: center;">' +
                            '<button class="btn" style="background: #e74c3c; color: #fff;" onclick="confirmDelete()">Delete</button>' +
                            '<button class="btn btn-secondary" onclick="cancelDelete()">Cancel</button>' +
                        '</div>' +
                    '</div>' +
                '</div>';
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function confirmDelete() {
            var fighterName = gameState.currentFighter.name;
            
            try {
                for (var i = 0; i < gameState.fighters.length; i++) {
                    if (gameState.fighters[i] && gameState.fighters[i].name === fighterName) {
                        gameState.fighters[i] = null;
                        break;
                    }
                }
                
                gameState.currentFighter = null;
                saveToSupabase();
                
                var modal = document.getElementById('deleteModal');
                if (modal) {
                    modal.remove();
                }
                
                alert(fighterName + ' has been deleted.');
                showTitleScreen();
                
            } catch (e) {
                console.error('Error deleting fighter:', e);
                alert('Error deleting fighter: ' + e.message);
            }
        }

        function cancelDelete() {
            var modal = document.getElementById('deleteModal');
            if (modal) {
                modal.remove();
            }
        }

function updateFighterDisplay() {
    var fighter = gameState.currentFighter;
    if (!fighter) return;

    // Initialize unallocated stats if not present
    if (fighter.unallocatedStats === undefined) {
        fighter.unallocatedStats = 0;
    }

    var specialDisplay;
if (fighter.specialAttack && fighter.specialAttack.name) {
    // Special attack damage (no strength bonus)
    var specialBaseDamage = fighter.level * 4 + 20;
    
    specialDisplay = '<div class="stat-row"><span>Special Attack:</span> <span class="special">' + 
        fighter.specialAttack.name + ' (' + specialBaseDamage + ' damage)</span></div>';
} else {
    specialDisplay = '<div class="stat-row"><span>Special Attack:</span> <span style="color: #888;">Unlocks at Level 10</span></div>';
}

    var strengthBonus = (fighter.stats.strength - 1) * 2;
var toughnessBonus = fighter.stats.toughness >= 2 ? Math.min(50, (fighter.stats.toughness - 1) * 0.6) : 0; // 0.6% per point, max 50%
var toughnessChance = Math.min(50, (fighter.stats.toughness - 1) * 0.5); // 0.5% per point, max 50%
var dodgeChance = Math.min(35, (fighter.stats.agility - 1) * 0.35); // 0.35% per point, max 35%
var speedBonus = Math.min(50, (fighter.stats.speed - 1) * 0.5); // Changed from 1%, max 50%
var critChance = Math.min(50, (fighter.stats.luck - 1) * 0.5); // 0.5% per point, max 50%
    // Calculate base damage and defense
    var baseDamage = 10;
    var weaponDamage = 0;
    var totalDefense = 0;
    
    // Calculate weapon damage
    if (fighter.equipment && fighter.equipment.weapon) {
        weaponDamage = fighter.equipment.weapon.power || 0;
    }
    
    // Calculate total defense from all equipment
    var equipmentSlotNames = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
    for (var i = 0; i < equipmentSlotNames.length; i++) {
        var slot = equipmentSlotNames[i];
        var item = fighter.equipment[slot];
        if (item && item.statType === 'Defense') {
            totalDefense += item.power || 0;
        }
    }
    
    var totalDamage = baseDamage + strengthBonus + weaponDamage;
    var damageBonus = strengthBonus + weaponDamage;

    // Calculate allocated points for reset cost
    var allocatedPoints = 0;
    allocatedPoints += (fighter.stats.strength - 1);
    allocatedPoints += (fighter.stats.toughness - 1);
    allocatedPoints += (fighter.stats.agility - 1);
    allocatedPoints += (fighter.stats.luck - 1);
    allocatedPoints += (fighter.stats.speed - 1);

    // Unallocated stats display
    var unallocatedDisplay = '';
    if (fighter.unallocatedStats > 0) {
        unallocatedDisplay = '<div style="background: rgba(255, 215, 0, 0.2); border: 1px solid #ffd700; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center;">' +
            '<div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">üéØ Available Stat Points: ' + fighter.unallocatedStats + '</div>' +
            '<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;">' +
                '<button class="btn" style="background: #ff6b6b; color: #fff; padding: 5px; font-size: 0.8em;" onclick="allocateStat(\'strength\')">+STR</button>' +
                '<button class="btn" style="background: #4ecdc4; color: #fff; padding: 5px; font-size: 0.8em;" onclick="allocateStat(\'toughness\')">+TOU</button>' +
                '<button class="btn" style="background: #74b9ff; color: #fff; padding: 5px; font-size: 0.8em;" onclick="allocateStat(\'agility\')">+AGI</button>' +
                '<button class="btn" style="background: #fdcb6e; color: #333; padding: 5px; font-size: 0.8em;" onclick="allocateStat(\'luck\')">+LUC</button>' +
                '<button class="btn" style="background: #6c5ce7; color: #fff; padding: 5px; font-size: 0.8em;" onclick="allocateStat(\'speed\')">+SPD</button>' +
            '</div>' +
        '</div>';
    }

    // Reset stats button (only show if points have been allocated)
    var resetStatsDisplay = '';
    if (allocatedPoints > 0) {
        resetStatsDisplay = '<div style="text-align: center; margin: 15px 0;">' +
            '<button class="btn" style="background: #e74c3c; color: #fff; padding: 8px 16px; font-size: 0.9em;" onclick="resetStats()">' +
            'üîÑ Reset Stats (' + allocatedPoints + ' üíé)' +
            '</button>' +
        '</div>';
    }

    var statsHTML = 
        '<div class="stat-row"><span>Name:</span> <span style="color: #4ecdc4; cursor: pointer; text-decoration: underline;" onclick="showRenameModal()" title="Click to rename (25 üíé)">' + fighter.name + '</span></div>' +
        '<div class="stat-row"><span>Level:</span> <span>' + fighter.level + '</span></div>' +
        '<div class="stat-row"><span>EXP:</span> <span>' + fighter.exp + '/' + fighter.expRequired + '</span></div>' +
        '<div class="stat-row"><span>Wins:</span> <span class="fighter-wins">' + fighter.wins + '</span></div>' +
        '<div class="stat-row"><span>HP:</span> <span>' + fighter.hp + '/' + fighter.maxHp + '</span></div>' +
        '<div class="stat-row"><span>Damage:</span> <span style="color: #ff6b6b;">' + baseDamage + 
            (damageBonus > 0 ? ' <span style="color: #6bcf7f;">(+' + damageBonus + ')</span>' : '') + '</span></div>' +
        '<div class="stat-row"><span>Defense:</span> <span style="color: #74b9ff;">' + 
    (totalDefense > 0 ? totalDefense + ' <span style="color: #888;">(-' + Math.min(60, totalDefense * 0.25).toFixed(1) + '% damage)</span>' : '0') + '</span></div>' +
        '<hr style="margin: 10px 0; border-color: rgba(255,255,255,0.2);">' +
        unallocatedDisplay +
        '<div class="stat-row"><span>Strength <span style="color: #888; font-size: 0.8em;">(+' + strengthBonus + ' damage)</span>:</span> <span>' + fighter.stats.strength + '</span></div>' +
        '<div class="stat-row"><span>Toughness <span style="color: #888; font-size: 0.8em;">(' + toughnessChance.toFixed(1) + '% chance for 50% damage reduction)</span>:</span> <span>' + fighter.stats.toughness + '</span></div>' +
        '<div class="stat-row"><span>Agility <span style="color: #888; font-size: 0.8em;">(' + dodgeChance.toFixed(1) + '% dodge chance)</span>:</span> <span>' + fighter.stats.agility + '</span></div>' +
        '<div class="stat-row"><span>Luck <span style="color: #888; font-size: 0.8em;">(' + critChance.toFixed(1) + '% crit chance)</span>:</span> <span>' + fighter.stats.luck + '</span></div>' +
        '<div class="stat-row"><span>Speed <span style="color: #888; font-size: 0.8em;">(' + speedBonus.toFixed(1) + '% extra attack chance)</span>:</span> <span>' + fighter.stats.speed + '</span></div>' +        
        resetStatsDisplay +
        '<hr style="margin: 10px 0; border-color: rgba(255,255,255,0.2);">' +
        specialDisplay;
    
    document.getElementById('fighterStats').innerHTML = statsHTML;

    var equipmentElement = document.getElementById('fighterEquipment');
    equipmentElement.innerHTML = '';
    
    for (var i = 0; i < equipmentSlots.length; i++) {
    var slot = equipmentSlots[i];
    var item = fighter.equipment[slot.toLowerCase().replace('-', '')];
    var slotDiv = document.createElement('div');
    slotDiv.className = 'equipment-slot';
    
    if (item && item.statType) {
        // Add item level and rarity to display
        var itemLevelText = item.itemLevel ? 'Lv.' + item.itemLevel + ' ' : '';
        var rarityText = item.rarity ? ' (' + item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1) + ')' : '';
        
        slotDiv.innerHTML = 
            '<div class="slot-name">' + slot + '</div>' +
            '<div class="item-content">' +
                '<div class="item-power">+' + item.power + ' ' + item.statType + '</div>' +
                '<div class="item-name ' + item.rarity + '" style="font-size: 0.75em;">' + 
                    itemLevelText + item.name + rarityText + 
                '</div>' +
            '</div>';
    } else {
        slotDiv.innerHTML = 
            '<div class="slot-name">' + slot + '</div>' +
            '<div class="item-content">' +
                '<div class="item-name">Empty</div>' +
            '</div>';
    }
    equipmentElement.appendChild(slotDiv);
}
}

        function allocateStat(statName) {
            var fighter = gameState.currentFighter;
            if (!fighter || fighter.unallocatedStats <= 0) {
                return;
            }
            
            fighter.stats[statName]++;
            fighter.unallocatedStats--;
            
            saveToSupabase();
            updateFighterDisplay();
        }

        function resetStats() {
    var fighter = gameState.currentFighter;
    if (!fighter) return;
    
    // Calculate total allocated stat points
    var allocatedPoints = 0;
    allocatedPoints += (fighter.stats.strength - 1);
    allocatedPoints += (fighter.stats.toughness - 1);
    allocatedPoints += (fighter.stats.agility - 1);
    allocatedPoints += (fighter.stats.luck - 1);
    allocatedPoints += (fighter.stats.speed - 1);
    
    // If no points have been allocated, nothing to reset
    if (allocatedPoints === 0) {
        alert('No stat points have been allocated yet!');
        return;
    }
    
    var diamondCost = allocatedPoints;
    
    // Check if player has enough diamonds
    if (gameState.diamonds < diamondCost) {
        alert('You need ' + diamondCost + ' üíé to reset your stats. You currently have ' + gameState.diamonds + ' üíé');
        return;
    }
    
    // Show confirmation modal instead of browser confirm
    showResetStatsModal(diamondCost, allocatedPoints);
}

function showResetStatsModal(diamondCost, allocatedPoints) {
    var existingModal = document.getElementById('resetStatsModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="resetStatsModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #e74c3c; max-width: 400px; width: 90%; text-align: center;">' +
                '<h3 style="color: #e74c3c; margin-bottom: 20px;">üîÑ Reset All Stats</h3>' +
                '<p style="color: #ffd93d; font-size: 1.1em; margin-bottom: 15px;">Cost: ' + diamondCost + ' üíé</p>' +
                '<p style="color: #ccc; margin-bottom: 20px;">This will reset all your stats to base level and refund <strong style="color: #4ecdc4;">' + allocatedPoints + ' stat points</strong> that you can reallocate.</p>' +
                '<p style="color: #888; font-size: 0.9em; margin-bottom: 25px;">Are you sure you want to proceed?</p>' +
                '<div style="display: flex; gap: 15px; justify-content: center;">' +
                    '<button class="btn" style="background: #e74c3c; color: #fff; padding: 12px 24px;" onclick="confirmResetStats(' + diamondCost + ', ' + allocatedPoints + ')">Reset Stats</button>' +
                    '<button class="btn btn-secondary" onclick="closeResetStatsModal()">Cancel</button>' +
                '</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeResetStatsModal() {
    var modal = document.getElementById('resetStatsModal');
    if (modal) {
        modal.remove();
    }
}

function confirmResetStats(diamondCost, allocatedPoints) {
    var fighter = gameState.currentFighter;
    if (!fighter) {
        closeResetStatsModal();
        return;
    }
    
    // Deduct diamonds
    gameState.diamonds -= diamondCost;
    
    // Reset stats to base
    fighter.stats = {
        strength: 1,
        toughness: 1,
        agility: 1,
        luck: 1,
        speed: 1
    };
    
    // Give back all stat points
    if (!fighter.unallocatedStats) {
        fighter.unallocatedStats = 0;
    }
    fighter.unallocatedStats += allocatedPoints;
    
    // Save and update display
    saveToSupabase();
    updateFighterDisplay();
    updateDiamondDisplay();
    
    // Close modal
    closeResetStatsModal();
    
    // Show success message
    alert('Stats reset successfully! You have ' + fighter.unallocatedStats + ' points to reallocate.');
}
        function updateFightStatus() {
            var now = Date.now();
            var fightBtn = document.getElementById('fightBtn');
            var fightWithoutRestBtn = document.getElementById('fightWithoutRestBtn');
            var cooldownTimer = document.getElementById('cooldownTimer');
            var diamondsDisplay = document.getElementById('diamonds');

            if (diamondsDisplay) {
                diamondsDisplay.textContent = gameState.diamonds;
            }

            if (fightWithoutRestBtn) {
                fightWithoutRestBtn.disabled = gameState.diamonds <= 0;
                fightWithoutRestBtn.textContent = 'Fight üíé';
            }

            if (now < gameState.fightCooldownEnd) {
                var timeLeft = gameState.fightCooldownEnd - now;
                var seconds = Math.ceil(timeLeft / 1000);
                
                if (fightBtn) {
                    fightBtn.disabled = true;
                    fightBtn.textContent = 'Resting (' + seconds + 's)';
                }
                
                if (cooldownTimer) {
                    cooldownTimer.textContent = 'Rest time remaining: ' + seconds + ' seconds';
                }
            } else {
                if (fightBtn) {
                    fightBtn.disabled = false;
                    fightBtn.textContent = 'Find Fight';
                }
                
                if (cooldownTimer) {
                    cooldownTimer.textContent = '';
                }
            }
        }

        function findFight() {
    var now = Date.now();
    if (now < gameState.fightCooldownEnd) {
        alert('You must rest before fighting again!');
        return;
    }
    if (!gameState.currentFighter) {
        alert('No fighter selected!');
        return;
    }
    
    // DON'T set cooldown here - it will be set when returning to fighter screen
    
    // Initialize fight tracking
    if (gameState.currentFighter.lossStreak === undefined) {
        gameState.currentFighter.lossStreak = 0;
    }
    if (gameState.currentFighter.totalFights === undefined) {
        gameState.currentFighter.totalFights = 0;
    }
    
    // 10% chance for boss battle (only at level 30+)
    var bossChance = 10;
    var canFightBoss = gameState.currentFighter.level >= 30 && gameState.currentFighter.totalFights >= 6;
    var isBossFight = canFightBoss && Math.random() * 100 < bossChance;
    
    if (isBossFight) {
        console.log('Boss battle encountered!');
        var bossOpponent = generateBossOpponent(gameState.currentFighter.level);
        startFight(gameState.currentFighter, bossOpponent, false);
        return;
    }
    
    // First 6 fights are guaranteed wins
    var guaranteedWin = gameState.currentFighter.totalFights < 6;
    
    // Check for lose streak protection (4+ losses in a row) - but not during first 6 fights
    if (!guaranteedWin && gameState.currentFighter.lossStreak >= 4) {
        console.log('Player has lost', gameState.currentFighter.lossStreak, 'times in a row - providing easier opponent');
        var easierLevel = Math.max(1, gameState.currentFighter.level - 3);
        var botOpponent = generateOpponent(easierLevel, true);
        startFight(gameState.currentFighter, botOpponent, false);
        return;
    }
    
    // For first 6 fights or levels 1-5, always fight bots
    if (guaranteedWin || gameState.currentFighter.level <= 5) {
        console.log(guaranteedWin ? 'Guaranteed win fight #' + (gameState.currentFighter.totalFights + 1) : 'Level ' + gameState.currentFighter.level + ' fighter - matching with bot opponent');
        var botOpponent = generateOpponent(gameState.currentFighter.level, guaranteedWin);
        startFight(gameState.currentFighter, botOpponent, false);
    } else {
        // Level 6+ can fight real players after first 6 fights
        console.log('Looking for real opponents for level', gameState.currentFighter.level, 'fighter...');
        findOpponentFromSupabase(gameState.currentFighter.level)
            .then(function(opponent) {
                if (opponent) {
                    console.log('Found real player opponent:', opponent.name, 'Level', opponent.level);
                    startFight(gameState.currentFighter, opponent, false);
                } else {
                    console.log('No real players found, generating AI opponent');
                    var botOpponent = generateOpponent(gameState.currentFighter.level, false);
                    startFight(gameState.currentFighter, botOpponent, false);
                }
            })
            .catch(function(error) {
                console.error('Matchmaking error, using AI opponent:', error);
                var botOpponent = generateOpponent(gameState.currentFighter.level, false);
                startFight(gameState.currentFighter, botOpponent, false);
            });
    }
}

function fightWithoutRest() {
    if (gameState.diamonds <= 0) {
        alert('You need Diamonds to fight without rest!');
        return;
    }
    gameState.diamonds--;
    saveToSupabase();
    updateDiamondDisplay();
    
    // Initialize fight tracking
    if (gameState.currentFighter.lossStreak === undefined) {
        gameState.currentFighter.lossStreak = 0;
    }
    if (gameState.currentFighter.totalFights === undefined) {
        gameState.currentFighter.totalFights = 0;
    }
    
    // 10% chance for boss battle (only at level 30+)
    var bossChance = 10;
    var canFightBoss = gameState.currentFighter.level >= 30 && gameState.currentFighter.totalFights >= 6;
    var isBossFight = canFightBoss && Math.random() * 100 < bossChance;
    
    if (isBossFight) {
        console.log('Boss battle encountered! (Diamond fight)');
        var bossOpponent = generateBossOpponent(gameState.currentFighter.level);
        startFight(gameState.currentFighter, bossOpponent, true);
        return;
    }
    
    // First 6 fights are guaranteed wins
    var guaranteedWin = gameState.currentFighter.totalFights < 6;
    
    // Check for lose streak protection (4+ losses in a row) - but not during first 6 fights
    if (!guaranteedWin && gameState.currentFighter.lossStreak >= 4) {
        console.log('Player has lost', gameState.currentFighter.lossStreak, 'times in a row - providing easier opponent');
        var easierLevel = Math.max(1, gameState.currentFighter.level - 3);
        var botOpponent = generateOpponent(easierLevel, true);
        botOpponent.stats.strength = Math.max(1, botOpponent.stats.strength - 1);
        botOpponent.stats.toughness = Math.max(1, botOpponent.stats.toughness - 1);
        startFight(gameState.currentFighter, botOpponent, true);
        return;
    }
    
    // For first 6 fights or levels 1-5, always fight bots
    if (guaranteedWin || gameState.currentFighter.level <= 5) {
        console.log(guaranteedWin ? 'Guaranteed win diamond fight #' + (gameState.currentFighter.totalFights + 1) : 'Level ' + gameState.currentFighter.level + ' diamond fight - matching with bot opponent');
        var botOpponent = generateOpponent(gameState.currentFighter.level, guaranteedWin);
        startFight(gameState.currentFighter, botOpponent, true);
    } else {
        console.log('Looking for opponents for diamond fight...');
        findOpponentFromSupabase(gameState.currentFighter.level)
            .then(function(opponent) {
                if (opponent) {
                    console.log('Found real player opponent for diamond fight:', opponent.name);
                    startFight(gameState.currentFighter, opponent, true);
                } else {
                    console.log('No real players found for diamond fight, generating AI opponent');
                    var botOpponent = generateOpponent(gameState.currentFighter.level, false);
                    startFight(gameState.currentFighter, botOpponent, true);
                }
            })
            .catch(function(error) {
                console.error('Diamond fight matchmaking error, using AI opponent:', error);
                var botOpponent = generateOpponent(gameState.currentFighter.level, false);
                startFight(gameState.currentFighter, botOpponent, true);
            });
    }
}

        function findOpponentFromSupabase(playerLevel) {
    // Only look for real players if the current fighter is level 6+ (but not level 9)
    if (playerLevel <= 5 || playerLevel === 9) {
        return Promise.resolve(null); // Force bot opponents for these levels
    }
    
    // Initialize recent opponents list if it doesn't exist
    if (!gameState.currentFighter.recentOpponents) {
        gameState.currentFighter.recentOpponents = [];
    }
    
    var minLevel = Math.max(6, playerLevel - 3);
    var maxLevel = playerLevel + 3;
    
    // Special case for level 9: don't match with level 10+
    if (playerLevel === 9) {
        maxLevel = 9;
    }
    
    var currentUserId = getUserId();
    
    console.log('Searching for opponents between level', minLevel, 'and', maxLevel);
    console.log('Recent opponents to avoid:', gameState.currentFighter.recentOpponents);
    
    return fetch(SUPABASE_URL + '/rest/v1/game_data?select=*', {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to fetch opponents: ' + response.status);
        }
        return response.json();
    })
    .then(function(allPlayers) {
        console.log('Found', allPlayers.length, 'total players in database');
        
        var validOpponents = [];
        
        for (var i = 0; i < allPlayers.length; i++) {
            var playerData = allPlayers[i];
            
            if (playerData.user_id === currentUserId) {
                continue;
            }
            
            if (!playerData.fighters || !Array.isArray(playerData.fighters)) {
                continue;
            }
            
            for (var j = 0; j < playerData.fighters.length; j++) {
                var fighter = playerData.fighters[j];
                
                if (fighter && fighter.level >= minLevel && fighter.level <= maxLevel) {
                    // Check if this fighter was recently fought
                    var fighterIdentifier = playerData.user_id + '_' + fighter.name;
                    if (gameState.currentFighter.recentOpponents.indexOf(fighterIdentifier) !== -1) {
                        console.log('Skipping recently fought opponent:', fighter.name);
                        continue;
                    }
                    
                    var opponent = {
                        name: fighter.name,
                        birthplace: fighter.birthplace || 'Unknown',
                        level: fighter.level,
                        hp: fighter.maxHp || (100 + (fighter.level - 1) * 20),
                        maxHp: fighter.maxHp || (100 + (fighter.level - 1) * 20),
                        currentHp: fighter.maxHp || (100 + (fighter.level - 1) * 20),
                        wins: fighter.wins || 0,
                        stats: fighter.stats || { strength: 1, toughness: 1, agility: 1, luck: 1, speed: 1 },
                        equipment: fighter.equipment || { weapon: { name: 'Basic Weapon', rarity: 'common' } },
                        specialAttack: fighter.specialAttack || null,
                        isRealPlayer: true,
                        originalUserId: playerData.user_id,
                        fighterIdentifier: fighterIdentifier
                    };
                    
                    validOpponents.push(opponent);
                }
            }
        }
        
        console.log('Found', validOpponents.length, 'valid opponents after filtering');
        
        if (validOpponents.length === 0) {
            return null;
        }
        
        var randomIndex = Math.floor(Math.random() * validOpponents.length);
        return validOpponents[randomIndex];
    })
    .catch(function(error) {
        console.error('Error finding opponents:', error);
        return null;
    });
}

        function generateOpponent(level, guaranteedLoss) {
    var names = ['ShadowKnight92', 'DragonSlayer', 'IronFist2024', 'BlazeFighter', 'StormWarrior', 'NightHunter', 'FlameStrike', 'IceBlade77', 'ThunderFist', 'DarkRaven','ShadowByteX', 'CrimsonNova', 'FrostClaw77', 'PixelRogue', 'BlazeSniper',
'IronWraith', 'VoidReaper', 'EchoFang', 'ToxicSpiral', 'NebulaHawk',
'GlitchFury', 'NightVortex', 'CyberWarden', 'StealthPulse', 'RapidVenom',
'DarkNovaX', 'PhantomCircuit', 'BlitzStriker', 'FrozenNemesis', 'QuantumDrift',
'RogueHydra', 'InfernoRift', 'SilentCry', 'ChaosHawk', 'StormCrawler',
'PulseReaper', 'ViralAssault', 'TitanGhost', 'HexVandal', 'SteelSpecter',
'LunarSnare', 'VortexShade', 'PixelMarauder', 'NebulaSplice', 'VenomCraze',
'SniperVeil', 'CrushDrifter', 'XenoQuake', 'AshRider', 'RageCircuit',
'StormFlicker', 'WarpedSoul', 'IonViper', 'DarkenedScope', 'ZeroDagger',
'ObsidianStrike', 'FuryPylon', 'EchoKnight', 'NitroPhantom', 'ShadowServo',
'MystSniper', 'TundraEdge', 'StaticBrawler', 'NovaWitch', 'TwilightFury',
'VoltageMancer', 'CryoSpark', 'SavageHound', 'StealthNova', 'WiredBane',
'NullByte', 'StrikerRift', 'FeralTracer', 'FrostHex', 'TerminalWraith',
'RiftRanger', 'ChaosByte', 'PulseHunter', 'IgnisShroud', 'CodedVenom',
'WildQuasar', 'BloodRayneX', 'SilentPhreak', 'DreadReactor', 'NovaTracer',
'FireHavoc', 'KarmaSnare', 'ToxicWarden', 'QuantumBlitz', 'FadedCore',
'IronLancer', 'GlitchKnight', 'NightmareXeno', 'PixelShade', 'BlitzGhoul',
'WraithForge', 'FrozenByte', 'ShockPulse', 'HoloDagger', 'CrimsonCrawler',
'NeoViperX', 'WarpFury', 'StaticScythe', 'GrimDrift', 'FuryQuanta',
'SnareWolf', 'SpectralCrush', 'NitroVenom', 'DarkTideX', 'OmegaCraze',
'FlameSnare', 'OblivionCore', 'StealthBlitz', 'ZenithGhoul', 'ZeroSnare'];
    var places = ['New York', 'London', 'Tokyo', 'Paris', 'Sydney'];
    
    var opponentLevel;
    if (guaranteedLoss) {
        opponentLevel = Math.max(1, level - 2); // 2 levels lower
    } else {
        opponentLevel = Math.max(1, level + Math.floor(Math.random() * 3) - 1);
    }
    
    // Calculate HP with scaling based on level
    var hpGain = 0;
    for (var lvl = 1; lvl < opponentLevel; lvl++) {
        if (lvl > 50) {
            hpGain += 50;
        } else if (lvl > 30) {
            hpGain += 35;
        } else if (lvl > 15) {
            hpGain += 25;
        } else {
            hpGain += 20;
        }
    }
    var opponentMaxHp = Math.floor(100 + hpGain);
    
    // If guaranteed loss, reduce HP further
    if (guaranteedLoss) {
        opponentMaxHp = Math.floor(opponentMaxHp * 0.7); // 30% less HP
    }
    
    // REBALANCED weapon variety based on level
    var weaponOptions = {
        low: [ // Levels 1-5
            { name: 'Rusty Sword', power: 5, rarity: 'common' },
            { name: 'Wooden Club', power: 4, rarity: 'common' },
            { name: 'Stone Axe', power: 6, rarity: 'common' },
            { name: 'Copper Dagger', power: 5, rarity: 'common' },
            { name: 'Training Staff', power: 4, rarity: 'common' }
        ],
        mid: [ // Levels 6-15
            { name: 'Iron Sword', power: 10, rarity: 'common' },
            { name: 'Steel Mace', power: 12, rarity: 'uncommon' },
            { name: 'Battle Axe', power: 11, rarity: 'common' },
            { name: 'War Hammer', power: 13, rarity: 'uncommon' },
            { name: 'Fine Spear', power: 11, rarity: 'uncommon' }
        ],
        high: [ // Levels 16-30
            { name: 'Knight\'s Blade', power: 18, rarity: 'uncommon' },
            { name: 'Tempered Sword', power: 22, rarity: 'rare' },
            { name: 'Warlord\'s Axe', power: 25, rarity: 'rare' },
            { name: 'Crystal Staff', power: 20, rarity: 'rare' },
            { name: 'Assassin\'s Edge', power: 23, rarity: 'rare' }
        ],
        elite: [ // Levels 31-50
            { name: 'Dragonslayer', power: 30, rarity: 'epic' },
            { name: 'Void Crusher', power: 35, rarity: 'epic' },
            { name: 'Phoenix Talon', power: 33, rarity: 'epic' },
            { name: 'Stormbreaker', power: 38, rarity: 'epic' },
            { name: 'Shadowfang', power: 36, rarity: 'epic' }
        ],
        master: [ // Levels 51-70
            { name: 'Champion\'s Edge', power: 40, rarity: 'epic' },
            { name: 'Royal Guard', power: 45, rarity: 'epic' },
            { name: 'Ancient Relic', power: 43, rarity: 'epic' },
            { name: 'Moonlight Blade', power: 48, rarity: 'epic' },
            { name: 'Sunfire Axe', power: 46, rarity: 'epic' }
        ],
        legendary: [ // Levels 71+
            { name: 'Apocalypse', power: 50, rarity: 'legendary' },
            { name: 'Ragnarok', power: 55, rarity: 'legendary' },
            { name: 'Godslayer', power: 60, rarity: 'mythic' },
            { name: 'Eternal Flame', power: 58, rarity: 'legendary' },
            { name: 'Cosmic Reaper', power: 65, rarity: 'mythic' }
        ]
    };
    
    // BALANCED weapon generation - match or slightly exceed player's weapon
    var playerWeaponPower = 0;
    var playerTotalArmor = 0;

    // Safely check for player equipment
    try {
        if (gameState && gameState.currentFighter && gameState.currentFighter.equipment) {
            if (gameState.currentFighter.equipment.weapon) {
                playerWeaponPower = gameState.currentFighter.equipment.weapon.power || 0;
            }
            
            // Calculate player's total armor
            var armorSlots = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
            for (var i = 0; i < armorSlots.length; i++) {
                var slot = armorSlots[i];
                var item = gameState.currentFighter.equipment[slot];
                if (item && item.statType === 'Defense') {
                    playerTotalArmor += item.power || 0;
                }
            }
        }
    } catch (e) {
        console.log('Error reading player equipment:', e);
    }

    // Select weapon tier based on level
    var weaponTier;
    if (opponentLevel <= 5) {
        weaponTier = weaponOptions.low;
    } else if (opponentLevel <= 15) {
        weaponTier = weaponOptions.mid;
    } else if (opponentLevel <= 30) {
        weaponTier = weaponOptions.high;
    } else if (opponentLevel <= 50) {
        weaponTier = weaponOptions.elite;
    } else if (opponentLevel <= 70) {
        weaponTier = weaponOptions.master;
    } else {
        weaponTier = weaponOptions.legendary;
    }

    // Random weapon from appropriate tier
    var selectedWeapon = weaponTier[Math.floor(Math.random() * weaponTier.length)];

    // Calculate weapon power
    var weaponPowerBonus = Math.floor(opponentLevel * 0.5);
    var baseWeaponPower = selectedWeapon.power + weaponPowerBonus;

    // If player has a weapon, match it or make bot weapon similar
    if (playerWeaponPower > 0) {
        var minBotWeapon = Math.floor(playerWeaponPower * 0.9);
        var maxBotWeapon = Math.floor(playerWeaponPower * 1.2);
        baseWeaponPower = Math.max(minBotWeapon, Math.min(maxBotWeapon, baseWeaponPower));
    }

    // Weaker weapons for guaranteed losses
    if (guaranteedLoss && baseWeaponPower > 5) {
        baseWeaponPower = Math.floor(baseWeaponPower * 0.6);
    }

    selectedWeapon.power = baseWeaponPower;

    // Generate armor for bots
    var botEquipment = {
        weapon: {
            name: selectedWeapon.name,
            rarity: selectedWeapon.rarity,
            power: selectedWeapon.power,
            statType: 'Damage'
        }
    };

    // Add defensive equipment for higher level bots
    if (opponentLevel >= 5) {
        var baseArmorPerSlot = playerTotalArmor > 0 ? Math.floor(playerTotalArmor / 7) : Math.floor(3 + opponentLevel * 0.4);
        baseArmorPerSlot = Math.max(baseArmorPerSlot, Math.floor(3 + opponentLevel * 0.4));
        
        if (opponentLevel >= 10) {
            botEquipment.chest = {
                name: 'Battle Armor',
                rarity: opponentLevel >= 15 ? 'rare' : 'uncommon',
                power: Math.floor(baseArmorPerSlot * 1.2),
                statType: 'Defense'
            };
        }
        
        if (opponentLevel >= 15) {
            botEquipment.helmet = {
                name: 'War Helm',
                rarity: opponentLevel >= 20 ? 'epic' : 'rare',
                power: Math.floor(baseArmorPerSlot * 0.8),
                statType: 'Defense'
            };
            
            botEquipment.offhand = {
                name: 'Tower Shield',
                rarity: opponentLevel >= 20 ? 'epic' : 'rare',
                power: Math.floor(baseArmorPerSlot * 1.0),
                statType: 'Defense'
            };
        }
        
        if (opponentLevel >= 20) {
            botEquipment.boots = {
                name: 'Plated Boots',
                rarity: 'epic',
                power: Math.floor(baseArmorPerSlot * 0.6),
                statType: 'Defense'
            };
            
            botEquipment.gloves = {
                name: 'Gauntlets',
                rarity: 'epic',
                power: Math.floor(baseArmorPerSlot * 0.6),
                statType: 'Defense'
            };
        }
        
        if (opponentLevel >= 25) {
            botEquipment.shoulders = {
                name: 'Pauldrons',
                rarity: 'epic',
                power: Math.floor(baseArmorPerSlot * 0.7),
                statType: 'Defense'
            };
            
            botEquipment.greaves = {
                name: 'Leg Guards',
                rarity: 'epic',
                power: Math.floor(baseArmorPerSlot * 0.7),
                statType: 'Defense'
            };
        }
    }
    
    // Stats distribution
    var stats = {
        strength: 1,
        toughness: 1,
        agility: 1,
        luck: 1,
        speed: 1
    };
    
    // For guaranteed losses, don't allocate all stat points
    var extraPoints = guaranteedLoss 
        ? Math.floor((opponentLevel - 1) * 0.5)
        : opponentLevel - 1;
    
    // For high-level bots, ensure minimum stats but more balanced
    if (opponentLevel >= 15 && !guaranteedLoss) {
        stats.strength = Math.min(4, Math.floor(opponentLevel / 5));
        stats.toughness = Math.min(4, Math.floor(opponentLevel / 5));
        stats.speed = Math.min(3, Math.floor(opponentLevel / 8)); // Give bots some speed
        extraPoints -= (stats.strength - 1) + (stats.toughness - 1) + (stats.speed - 1);
    }
    
    // Distribute remaining points with more balanced weights
    var statNames = ['strength', 'toughness', 'agility', 'luck', 'speed'];
    for (var i = 0; i < extraPoints; i++) {
        var weights = opponentLevel >= 15 
            ? [25, 30, 15, 15, 15] // Better speed allocation for high level bots
            : [30, 25, 15, 15, 15]; // More balanced for all levels
            
        var totalWeight = weights.reduce(function(sum, w) { return sum + w; }, 0);
        var random = Math.random() * totalWeight;
        
        var currentWeight = 0;
        for (var j = 0; j < statNames.length; j++) {
            currentWeight += weights[j];
            if (random <= currentWeight) {
                stats[statNames[j]]++;
                break;
            }
        }
    }
    
    return {
        name: names[Math.floor(Math.random() * names.length)],
        birthplace: places[Math.floor(Math.random() * places.length)],
        level: opponentLevel,
        hp: opponentMaxHp,
        maxHp: opponentMaxHp,
        currentHp: opponentMaxHp,
        wins: Math.floor(opponentLevel * 3),
        stats: stats,
        equipment: botEquipment,
        specialAttack: opponentLevel >= 10 ? {
            name: generateSpecialAttackName()
        } : null,
        isRealPlayer: false,
        isBot: true
    };
}
function generateBossOpponent(playerLevel) {
    var bossNames = [
        'The Devourer', 'Shadow Tyrant', 'Crimson Overlord', 'Void Emperor', 'Death Incarnate',
        'The Annihilator', 'Chaos Lord', 'Eternal Destroyer', 'Nightmare King', 'Blood Sovereign',
        'The Executioner', 'Doom Bringer', 'Infernal Warlord', 'Dark Harbinger', 'The Ravager',
        'Oblivion Master', 'Cataclysm', 'The Reaper', 'Abyssal Fiend', 'Vengeance Incarnate',
        'The Tormentor', 'Plague Bearer', 'Skull Crusher', 'Soul Eater', 'The Desecrator',
        'Crimson Nightmare', 'Shadow Demon', 'The Butcher', 'Wraith Lord', 'The Defiler',
        'Bone Collector', 'The Malevolent', 'Dread King', 'The Corruptor', 'Venom Master',
        'The Slaughterer', 'Dark Apostle', 'The Impaler', 'Hellfire Lord', 'The Damned One',
        'Chaos Incarnate', 'The Scourge', 'Death\'s Shadow', 'The Tyrant', 'Abyss Walker',
        'The Fallen One', 'Nightmare Spawn', 'The Dreadlord', 'Obsidian Fiend', 'The Conqueror'
    ];
    
    // Boss-specific legendary weapons that match their theme
    var bossWeapons = [
        { name: 'Fang of the Devourer', type: 'Dagger' },
        { name: 'Scepter of Shadows', type: 'Staff' },
        { name: 'Crimson Reaver', type: 'Axe' },
        { name: 'Void Scythe', type: 'Scythe' },
        { name: 'Death\'s Embrace', type: 'Scythe' },
        { name: 'The Annihilator', type: 'Hammer' },
        { name: 'Chaos Blade', type: 'Sword' },
        { name: 'Eternity\'s End', type: 'Greatsword' },
        { name: 'Nightmare\'s Edge', type: 'Sword' },
        { name: 'Bloodletter', type: 'Axe' },
        { name: 'The Executioner\'s Axe', type: 'Axe' },
        { name: 'Doomhammer', type: 'Hammer' },
        { name: 'Inferno\'s Wrath', type: 'Mace' },
        { name: 'Harbinger of Ruin', type: 'Halberd' },
        { name: 'The Ravager\'s Claw', type: 'Gauntlet' },
        { name: 'Staff of Oblivion', type: 'Staff' },
        { name: 'World Ender', type: 'Greatsword' },
        { name: 'Soul Reaper', type: 'Scythe' },
        { name: 'Abyssal Maw', type: 'Mace' },
        { name: 'Vengeance Incarnate', type: 'Sword' },
        { name: 'The Tormentor\'s Flail', type: 'Flail' },
        { name: 'Pestilence', type: 'Staff' },
        { name: 'Skull Splitter', type: 'Hammer' },
        { name: 'Soul Drinker', type: 'Blade' },
        { name: 'Profane Edge', type: 'Sword' },
        { name: 'Crimson Terror', type: 'Axe' },
        { name: 'Shadow Fang', type: 'Dagger' },
        { name: 'Butcher\'s Cleaver', type: 'Cleaver' },
        { name: 'Wraith Caller', type: 'Staff' },
        { name: 'Corruption', type: 'Sword' },
        { name: 'Bone Crusher', type: 'Mace' },
        { name: 'Malice', type: 'Blade' },
        { name: 'Crown of Dread', type: 'Scepter' },
        { name: 'The Corruptor\'s Touch', type: 'Staff' },
        { name: 'Venom Fang', type: 'Spear' },
        { name: 'The Slaughterer', type: 'Axe' },
        { name: 'Dark Covenant', type: 'Sword' },
        { name: 'The Impaler', type: 'Spear' },
        { name: 'Hellfire Brand', type: 'Sword' },
        { name: 'Damnation', type: 'Greatsword' },
        { name: 'Chaos Incarnate', type: 'Blade' },
        { name: 'The Scourge', type: 'Whip' },
        { name: 'Shadow\'s Grasp', type: 'Claw' },
        { name: 'Tyranny', type: 'Mace' },
        { name: 'Abyssal Blade', type: 'Sword' },
        { name: 'Fallen Grace', type: 'Sword' },
        { name: 'Nightmare Manifest', type: 'Staff' },
        { name: 'The Dreadlord\'s Glaive', type: 'Glaive' },
        { name: 'Obsidian Fang', type: 'Dagger' },
        { name: 'The Conqueror\'s Blade', type: 'Sword' }
    ];
    
    var bossLevel = Math.max(playerLevel, playerLevel + Math.floor(Math.random() * 3)); // Same level or higher
    
    // Boss has significantly more HP
    var hpGain = 0;
    for (var lvl = 1; lvl < bossLevel; lvl++) {
        if (lvl > 50) {
            hpGain += 50;
        } else if (lvl > 30) {
            hpGain += 35;
        } else if (lvl > 15) {
            hpGain += 25;
        } else {
            hpGain += 20;
        }
    }
    var bossMaxHp = Math.floor((100 + hpGain) * 1.5); // 50% more HP than normal
    
    // Select boss name and matching weapon
    var bossIndex = Math.floor(Math.random() * bossNames.length);
    var bossName = bossNames[bossIndex];
    var bossWeapon = bossWeapons[bossIndex];
    
    // Boss weapon - always powerful and legendary/mythic
    var weaponRarity = Math.random() < 0.3 ? 'mythic' : 'legendary'; // 30% mythic, 70% legendary
    var bossWeaponPower = Math.floor(bossLevel * 3 + 20); // Strong weapon
    
    var bossWeaponItem = {
        name: bossWeapon.name,
        rarity: weaponRarity,
        power: bossWeaponPower,
        statType: 'Damage',
        weaponType: bossWeapon.type // Store the weapon type for flavor
    };
    
    // Boss equipment - well-armored
    var bossEquipment = {
        weapon: bossWeaponItem
    };
    
    // Add defensive equipment
    var armorPower = Math.floor(5 + bossLevel * 0.6);
    
    if (bossLevel >= 10) {
        bossEquipment.chest = {
            name: 'Boss Armor',
            rarity: 'epic',
            power: armorPower,
            statType: 'Defense'
        };
        bossEquipment.helmet = {
            name: 'Boss Helm',
            rarity: 'epic',
            power: Math.floor(armorPower * 0.7),
            statType: 'Defense'
        };
        bossEquipment.offhand = {
            name: 'Boss Shield',
            rarity: 'epic',
            power: Math.floor(armorPower * 0.8),
            statType: 'Defense'
        };
    }
    
    // Boss stats - well-rounded and powerful
    var stats = {
        strength: Math.max(3, Math.floor(bossLevel / 4)),
        toughness: Math.max(3, Math.floor(bossLevel / 4)),
        agility: Math.max(2, Math.floor(bossLevel / 6)),
        luck: Math.max(2, Math.floor(bossLevel / 6)),
        speed: Math.max(2, Math.floor(bossLevel / 6))
    };
    
    // Distribute extra points
    var extraPoints = Math.floor(bossLevel * 0.7);
    var statNames = ['strength', 'toughness', 'agility', 'luck', 'speed'];
    for (var i = 0; i < extraPoints; i++) {
        var randomStat = statNames[Math.floor(Math.random() * statNames.length)];
        stats[randomStat]++;
    }
    
    return {
        name: bossName,
        birthplace: 'The Abyss',
        level: bossLevel,
        hp: bossMaxHp,
        maxHp: bossMaxHp,
        currentHp: bossMaxHp,
        wins: Math.floor(bossLevel * 10),
        stats: stats,
        equipment: bossEquipment,
        specialAttack: bossLevel >= 10 ? {
            name: generateSpecialAttackName()
        } : null,
        isRealPlayer: false,
        isBot: true,
        isBoss: true // Mark as boss
    };
}

        
        function updateLeaderboard() {
    var content = document.getElementById('leaderboardContent');
    
    // Check if user is a guest
    if (gameState.currentUser && gameState.currentUser.isGuest) {
        content.innerHTML = 
            '<div style="text-align: center; padding: 40px 20px;">' +
                '<div style="background: rgba(245, 158, 11, 0.2); border: 2px solid #f59e0b; border-radius: 10px; padding: 30px; max-width: 500px; margin: 0 auto;">' +
                    '<h3 style="color: #f59e0b; margin-bottom: 20px;">üìä Global Leaderboard</h3>' +
                    '<p style="color: #ccc; margin-bottom: 20px; font-size: 1.1em;">You\'re playing as a guest!</p>' +
                    '<p style="color: #888; margin-bottom: 25px;">Create an account to enter the leaderboards and compete with players worldwide. Your current progress will be saved!</p>' +
                    '<button class="btn btn-primary" onclick="createAccountFromGuest()" style="padding: 12px 30px; font-size: 1.1em;">Create Account</button>' +
                '</div>' +
            '</div>';
        return;
    }
    
    content.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Loading leaderboard...</div>';
    
    fetch('https://pmsbxvqavkoboxyhqjcc.supabase.co/rest/v1/game_data?select=fighters,user_id', {
        method: 'GET',
        headers: {
            'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc2J4dnFhdmtvYm94eWhxamNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NjA2OTMsImV4cCI6MjA3MzIzNjY5M30.9-0-glSFo66fOktfR6ineO8J4Ra8RLVXwytCb9jca9U'
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to fetch leaderboard');
        }
        return response.json();
    })
    .then(function(allPlayers) {
        var leaderboard = [];
        var currentUserFighters = [];
        
        // Collect all fighters from all players
        for (var i = 0; i < allPlayers.length; i++) {
            var playerData = allPlayers[i];
            if (playerData.fighters && Array.isArray(playerData.fighters)) {
                for (var j = 0; j < playerData.fighters.length; j++) {
                    var fighter = playerData.fighters[j];
                    if (fighter && fighter.name) {
                        var fighterEntry = {
    name: fighter.name,
    wins: fighter.wins || 0,
    level: fighter.level || 1,
    isCurrentUser: false,
    userId: playerData.user_id
};
                        
                        // Check if this fighter belongs to the current user
                        if (gameState.currentUser && playerData.user_id === gameState.currentUser.user_id) {
                            fighterEntry.isCurrentUser = true;
                            currentUserFighters.push(fighterEntry.name);
                        }
                        
                        leaderboard.push(fighterEntry);
                    }
                }
            }
        }
        
        // Sort by wins (descending)
        leaderboard.sort(function(a, b) {
            return b.wins - a.wins;
        });
        
        if (leaderboard.length === 0) {
            content.innerHTML = 
                '<div style="text-align: center; padding: 20px; color: #888;">' +
                    '<p>No fighters yet!</p>' +
                    '<p>Be the first to create a fighter!</p>' +
                '</div>';
            return;
        }
        
        // Show top 50 fighters
        var html = '';
        var displayCount = Math.min(50, leaderboard.length);
        
        for (var i = 0; i < displayCount; i++) {
            var entry = leaderboard[i];
            var rank = i + 1;
            var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank + '.';
            
            // Highlight current user's fighters
            var highlightStyle = entry.isCurrentUser ? ' style="background: rgba(78, 205, 196, 0.1); border-radius: 5px;"' : '';
            var yourFighterTag = entry.isCurrentUser ? ' <span style="color: #4ecdc4; font-size: 0.8em;">(You)</span>' : '';
            
            // Store user_id on the entry for profile viewing
var nameClickable = entry.userId ? 
    '<span style="cursor: pointer; text-decoration: underline;" onclick="showPlayerProfile(\'' + entry.name.replace(/'/g, "\\'") + '\', \'' + entry.userId + '\')">' + entry.name + '</span>' : 
    entry.name;

html += 
    '<div class="leaderboard-entry"' + highlightStyle + '>' +
        '<span>' + medal + ' ' + nameClickable + yourFighterTag + ' (Level ' + entry.level + ')</span>' +
        '<span>' + entry.wins + ' wins</span>' +
    '</div>';
        }
        
        content.innerHTML = html;
    })
    .catch(function(error) {
        console.error('Leaderboard error:', error);
        content.innerHTML = 
            '<div style="text-align: center; padding: 20px; color: #888;">' +
                '<p>Failed to load leaderboard</p>' +
                '<p>Please check your connection and try again</p>' +
            '</div>';
    });
}

        // Battle Events System
var battleEvents = [
    {
        id: 'thrown_rock',
        title: 'ü™® INCOMING PROJECTILE!',
        description: '{opponent} picks up a rock and hurls it at you with tremendous force!',
        options: [
            {
                name: 'Dodge',
                stat: 'agility',
                description: 'Use your agility to sidestep the rock',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You nimbly dodge the rock!',
                    fail: 'The rock hits you!'
                }
            },
            {
                name: 'Block',
                stat: 'toughness',
                description: 'Brace yourself and block with your arms',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You block most of the impact!',
                    fail: 'The rock breaks through your guard!'
                }
            },
            {
                name: 'Pray to Lady Luck',
                stat: 'luck',
                description: 'Hope the rock misses you',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'The rock miraculously veers off course!',
                    fail: 'Lady Luck abandons you - the rock hits!'
                }
            }
        ]
    },
    {
        id: 'dust_cloud',
        title: 'üí® BLINDING DUST!',
        description: '{opponent} kicks up a massive cloud of dust, obscuring your vision!',
        options: [
            {
                name: 'Close Eyes & Listen',
                stat: 'agility',
                description: 'Rely on hearing to anticipate the attack',
                successEffect: 'counter',
                failEffect: 'normal',
                effectText: {
                    success: 'You hear the attack coming and counter perfectly!',
                    fail: 'You misjudge the direction and get hit!'
                }
            },
            {
                name: 'Stand Ground',
                stat: 'toughness',
                description: 'Protect yourself and endure the attack',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You weather the blind assault!',
                    fail: 'The surprise attack overwhelms you!'
                }
            },
            {
                name: 'Charge Forward',
                stat: 'strength',
                description: 'Rush through the dust and attack',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You land a devastating blow through the dust!',
                    fail: 'You stumble blindly and take extra damage!'
                }
            }
        ]
    },
    {
        id: 'weapon_break',
        title: '‚öîÔ∏è WEAPON CLASH!',
        description: 'Your weapons collide with incredible force! One might break!',
        options: [
            {
                name: 'Overpower',
                stat: 'strength',
                description: 'Use raw strength to dominate',
                successEffect: 'counter',
                failEffect: 'normal',
                effectText: {
                    success: 'You overpower your opponent and strike!',
                    fail: 'Your opponent pushes you back and attacks!'
                }
            },
            {
                name: 'Deflect',
                stat: 'agility',
                description: 'Use finesse to redirect the force',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You skillfully deflect and avoid damage!',
                    fail: 'The deflection fails and you take the hit!'
                }
            },
            {
                name: 'Hold Firm',
                stat: 'toughness',
                description: 'Lock weapons and endure the strain',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You hold firm and minimize the impact!',
                    fail: 'Your defense crumbles under pressure!'
                }
            }
        ]
    },
    {
        id: 'ground_shake',
        title: '‚ö° GROUND TREMOR!',
        description: '{opponent} strikes the ground, causing it to shake violently beneath you!',
        options: [
            {
                name: 'Jump',
                stat: 'agility',
                description: 'Leap into the air to avoid the shockwave',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You leap over the shockwave gracefully!',
                    fail: 'You mistimed the jump and fall hard!'
                }
            },
            {
                name: 'Plant Feet',
                stat: 'toughness',
                description: 'Root yourself and resist the tremor',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You stand firm like a mountain!',
                    fail: 'The tremor knocks you off balance!'
                }
            },
            {
                name: 'Roll Away',
                stat: 'speed',
                description: 'Quickly roll to stable ground',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You swiftly roll to safety!',
                    fail: 'You stumble while rolling and get hit!'
                }
            }
        ]
    },
    {
        id: 'feint_attack',
        title: 'üé≠ DECEPTIVE STRIKE!',
        description: '{opponent} feints an attack! Can you read their true intention?',
        options: [
            {
                name: 'Predict Movement',
                stat: 'luck',
                description: 'Trust your instincts',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You predicted correctly and counter!',
                    fail: 'You fell for the feint completely!'
                }
            },
            {
                name: 'React Quickly',
                stat: 'speed',
                description: 'Wait and react to the real attack',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'Your quick reflexes save you!',
                    fail: 'You react too late!'
                }
            },
            {
                name: 'Full Defense',
                stat: 'toughness',
                description: 'Guard against all possibilities',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'Your solid defense holds!',
                    fail: 'The attack finds a gap in your defense!'
                }
            }
        ]
    },
    {
        id: 'spinning_attack',
        title: 'üå™Ô∏è WHIRLWIND ASSAULT!',
        description: '{opponent} begins spinning rapidly with weapon extended!',
        options: [
            {
                name: 'Backstep',
                stat: 'speed',
                description: 'Quickly retreat out of range',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You retreat just in time!',
                    fail: 'You weren\'t fast enough to escape!'
                }
            },
            {
                name: 'Duck Under',
                stat: 'agility',
                description: 'Slide beneath the spinning blade',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You slide under and strike from below!',
                    fail: 'The blade catches you while ducking!'
                }
            },
            {
                name: 'Endure',
                stat: 'toughness',
                description: 'Brace for the spinning strikes',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You endure the assault with minimal damage!',
                    fail: 'The spinning attack batters you!'
                }
            }
        ]
    },
    {
        id: 'overhead_smash',
        title: 'üí• DEVASTATING OVERHEAD!',
        description: '{opponent} raises their weapon high for a crushing overhead smash!',
        options: [
            {
                name: 'Side Roll',
                stat: 'agility',
                description: 'Roll to the side at the last moment',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You roll aside as the weapon crashes down!',
                    fail: 'You didn\'t roll far enough!'
                }
            },
            {
                name: 'Parry Upward',
                stat: 'strength',
                description: 'Meet the attack with your own force',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You deflect the attack and counter!',
                    fail: 'The overhead attack crushes through your parry!'
                }
            },
            {
                name: 'Cross Block',
                stat: 'toughness',
                description: 'Block with weapon held horizontally',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'Your block absorbs most of the force!',
                    fail: 'The overhead attack breaks through!'
                }
            }
        ]
    },
    {
        id: 'charge_attack',
        title: 'üêÇ CHARGING RUSH!',
        description: '{opponent} lowers their stance and charges at you like a bull!',
        options: [
            {
                name: 'Sidestep',
                stat: 'speed',
                description: 'Move out of the way quickly',
                successEffect: 'avoided',
                failEffect: 'increased',
                effectText: {
                    success: 'You sidestep elegantly!',
                    fail: 'The charge catches you!'
                }
            },
            {
                name: 'Stand Firm',
                stat: 'strength',
                description: 'Meet the charge head-on',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You stop the charge and counter!',
                    fail: 'You get bowled over!'
                }
            },
            {
                name: 'Brace for Impact',
                stat: 'toughness',
                description: 'Prepare to absorb the collision',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You weather the charge!',
                    fail: 'The impact staggers you!'
                }
            }
        ]
    },
    {
        id: 'throwing_knife',
        title: 'üó°Ô∏è HIDDEN BLADE!',
        description: '{opponent} suddenly produces a throwing knife and aims at you!',
        options: [
            {
                name: 'Deflect',
                stat: 'agility',
                description: 'Swat the knife away',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You deflect the knife with your weapon!',
                    fail: 'The knife grazes you!'
                }
            },
            {
                name: 'Matrix Dodge',
                stat: 'luck',
                description: 'Attempt an impossible dodge',
                successEffect: 'counter',
                failEffect: 'normal',
                effectText: {
                    success: 'You dodge impossibly and counter-attack!',
                    fail: 'The knife finds its mark!'
                }
            },
            {
                name: 'Tank It',
                stat: 'toughness',
                description: 'Let your armor absorb it',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'Your armor deflects the blade!',
                    fail: 'The knife pierces through!'
                }
            }
        ]
    },
    {
        id: 'grapple_attempt',
        title: 'ü§º GRAPPLE ATTEMPT!',
        description: '{opponent} rushes in to grab and grapple you!',
        options: [
            {
                name: 'Break Free',
                stat: 'strength',
                description: 'Use raw power to escape',
                successEffect: 'counter',
                failEffect: 'increased',
                effectText: {
                    success: 'You break free and strike back!',
                    fail: 'You\'re caught in the grapple!'
                }
            },
            {
                name: 'Slip Away',
                stat: 'agility',
                description: 'Use technique to escape the hold',
                successEffect: 'avoided',
                failEffect: 'normal',
                effectText: {
                    success: 'You slip out of the grapple!',
                    fail: 'You get caught!'
                }
            },
            {
                name: 'Counter-Grapple',
                stat: 'toughness',
                description: 'Reverse the grapple',
                successEffect: 'reduced',
                failEffect: 'normal',
                effectText: {
                    success: 'You reverse the position!',
                    fail: 'The grapple overwhelms you!'
                }
            }
        ]
    }
];

var currentBattleEvent = null;
var eventTimer = null;

function shouldTriggerBattleEvent(turnCount, player, opponent) {
    // Only trigger once per battle
    if (currentBattleEvent) {
        return false;
    }
    
    // Check if either player is below 50% HP - don't trigger event if fight is almost over
    var playerHpPercent = (player.currentHp / player.maxHp) * 100;
    var opponentHpPercent = (opponent.currentHp / opponent.maxHp) * 100;
    
    if (playerHpPercent < 50 || opponentHpPercent < 50) {
        console.log('Event skipped: One fighter below 50% HP');
        return false;
    }
    
    // 25% chance to trigger on turns 2-5 (early/mid fight)
    if (turnCount >= 2 && turnCount <= 5) {
        return Math.random() * 100 < 25;
    }
    
    return false;
}

function triggerBattleEvent(player, opponent) {
    // Select random event
    var randomEvent = battleEvents[Math.floor(Math.random() * battleEvents.length)];
    currentBattleEvent = {
        event: randomEvent,
        player: player,
        opponent: opponent,
        resolved: false
    };
    
    showBattleEventModal(randomEvent, player, opponent);
}

function showBattleEventModal(event, player, opponent) {
    var description = event.description.replace('{opponent}', opponent.name);
    
    var optionsHTML = '';
    for (var i = 0; i < event.options.length; i++) {
        var option = event.options[i];
        var stat = option.stat;
        var statValue = player.stats[stat];
        var successChance = calculateEventSuccessChance(statValue);
        
        optionsHTML += 
            '<div class="event-option" onclick="selectEventOption(' + i + ')">' +
                '<div class="event-option-title">' + option.name + '</div>' +
                '<div class="event-option-stat">' + stat.charAt(0).toUpperCase() + stat.slice(1) + ' ' + statValue + '</div>' +
                '<div class="event-option-chance">' + successChance + '% Success Chance</div>' +
                '<div class="event-option-effect">' + option.description + '</div>' +
            '</div>';
    }
    
    var modalHTML = 
        '<div id="battleEventModal" class="event-modal">' +
            '<div class="event-container">' +
                '<div class="event-title">' + event.title + '</div>' +
                '<div class="event-description">' + description + '</div>' +
                '<div class="event-timer" id="eventTimer">Time remaining: <span id="eventTimerCount">30</span>s</div>' +
                '<div class="event-options">' + optionsHTML + '</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    startEventTimer();
}

function calculateEventSuccessChance(statValue) {
    // New Formula: Base 5% + (stat value * 1.5%)
    // Example: Stat 1 = 6.5%, Stat 10 = 20%, Stat 25 = 42.5%, Stat 50 = 80%, Stat 63+ = 100%
    // This makes low stats much harder and requires higher investment for guaranteed success
    return Math.min(100, 5 + (statValue * 1.5));
}

function startEventTimer() {
    var timeLeft = 30;
    var timerElement = document.getElementById('eventTimerCount');
    var timerContainer = document.getElementById('eventTimer');
    
    eventTimer = setInterval(function() {
        timeLeft--;
        if (timerElement) {
            timerElement.textContent = timeLeft;
        }
        
        if (timeLeft <= 10 && timerContainer) {
            timerContainer.classList.add('urgent');
        }
        
        if (timeLeft <= 0) {
            clearInterval(eventTimer);
            // Auto-select random option
            var randomOption = Math.floor(Math.random() * currentBattleEvent.event.options.length);
            selectEventOption(randomOption, true);
        }
    }, 1000);
}

function selectEventOption(optionIndex, autoSelected) {
    if (!currentBattleEvent || currentBattleEvent.resolved) return;
    
    clearInterval(eventTimer);
    
    var event = currentBattleEvent.event;
    var option = event.options[optionIndex];
    var player = currentBattleEvent.player;
    var statValue = player.stats[option.stat];
    var successChance = calculateEventSuccessChance(statValue);
    
    var success = Math.random() * 100 < successChance;
    
    currentBattleEvent.resolved = true;
    currentBattleEvent.result = {
        option: option,
        success: success,
        autoSelected: autoSelected
    };
    
    closeBattleEventModal();
    showEventResult(option, success, autoSelected);
}

function closeBattleEventModal() {
    var modal = document.getElementById('battleEventModal');
    if (modal) {
        modal.remove();
    }
}

function showEventResult(option, success, autoSelected) {
    var resultText = success ? option.effectText.success : option.effectText.fail;
    
    if (autoSelected) {
        addToFightLog('<span style="color: #888;">‚è±Ô∏è Time ran out! Randomly chose: ' + option.name + '</span>');
    }
    
    if (success) {
        addToFightLog('<span style="color: #6bcf7f; font-weight: bold; font-size: 1.1em;">‚úÖ EVENT SUCCESS! ' + resultText + '</span>');
        
        // Show what effect will happen
        if (option.successEffect === 'avoided') {
            addToFightLog('<span style="color: #6bcf7f;">‚Üí You will take NO damage from the next attack!</span>');
        } else if (option.successEffect === 'counter') {
            addToFightLog('<span style="color: #6bcf7f;">‚Üí You will COUNTER the next attack!</span>');
        } else if (option.successEffect === 'reduced') {
            addToFightLog('<span style="color: #6bcf7f;">‚Üí You will take 50% LESS damage from the next attack!</span>');
        }
    } else {
        addToFightLog('<span style="color: #ff6b6b; font-weight: bold; font-size: 1.1em;">‚ùå EVENT FAILED! ' + resultText + '</span>');
        
        // Show what effect will happen
        if (option.failEffect === 'normal') {
            addToFightLog('<span style="color: #888;">‚Üí You will take normal damage from the next attack.</span>');
        } else if (option.failEffect === 'increased') {
            addToFightLog('<span style="color: #ff6b6b;">‚Üí You will take 50% MORE damage from the next attack!</span>');
        }
    }
}

function getEventEffect() {
    if (!currentBattleEvent || !currentBattleEvent.resolved) {
        return null;
    }
    
    // If already used, don't return it again
    if (currentBattleEvent.effectUsed) {
        return null;
    }
    
    var result = currentBattleEvent.result;
    var effect = result.success ? result.option.successEffect : result.option.failEffect;
    
    // Determine if this event involves a projectile/object
    var eventId = currentBattleEvent.event.id;
    var usesObject = ['thrown_rock', 'throwing_knife', 'dust_cloud'].indexOf(eventId) !== -1;
    var objectName = '';
    
    if (eventId === 'thrown_rock') {
        objectName = 'rock';
    } else if (eventId === 'throwing_knife') {
        objectName = 'throwing knife';
    } else if (eventId === 'dust_cloud') {
        objectName = 'dust cloud attack';
    }
    
    // DON'T mark as used here - let performAttack mark it when actually applied
    
    return {
        effect: effect,
        applied: false,
        usesObject: usesObject,
        objectName: objectName
    };
}

function startFight(player, opponent, isDiamondFight) {
    hideAll();
    var fightScreen = document.getElementById('fightScreen');
    fightScreen.style.display = 'block';
    
    // Change background color to blood red if boss fight
    if (opponent.isBoss) {
        fightScreen.style.background = 'linear-gradient(135deg, #8B0000, #4a0000)';
    } else {
        fightScreen.style.background = 'linear-gradient(135deg, #1a1a2e, #16213e)';
    }
    
    // Hide the header and logo during fights
    var headerContainer = document.querySelector('h1.title');
    if (headerContainer) {
        headerContainer.style.display = 'none';
    }
    var companyLogo = document.querySelector('.company-logo');
    if (companyLogo) {
        companyLogo.style.display = 'none';
    }
            
    player.currentHp = player.maxHp;
    opponent.currentHp = opponent.maxHp;
    
    // IMPORTANT: Reset special attack state completely for both fighters
    player.specialAvailable = player.level >= 10 && player.specialAttack ? true : false;
    opponent.specialAvailable = opponent.level >= 10 && opponent.specialAttack ? true : false;
    player.specialUsed = false;
    opponent.specialUsed = false;
    player.useSpecialNext = false; // Reset this flag
    opponent.useSpecialNext = false; // Reset this flag
    
    // Hide the special meter bars (no longer needed)
    var player1SpecialContainer = document.getElementById('player1Special').parentElement.parentElement;
    var player2SpecialContainer = document.getElementById('player2Special').parentElement.parentElement;
    player1SpecialContainer.style.display = 'none';
    player2SpecialContainer.style.display = 'none';
    
    // Show and enable special attack button if available
    var player1SpecialBtn = document.getElementById('player1SpecialBtn');
    if (player.specialAvailable) {
        player1SpecialBtn.style.display = 'block';
        player1SpecialBtn.disabled = false;
        player1SpecialBtn.style.opacity = '1';
        player1SpecialBtn.style.cursor = 'pointer';
        player1SpecialBtn.textContent = '‚ö° Use ' + player.specialAttack.name;
        player1SpecialBtn.parentElement.style.display = 'block';
    } else {
        player1SpecialBtn.style.display = 'none';
    }
            
    // Store whether this is a diamond fight and boss fight
    player.isDiamondFight = isDiamondFight;
    player.isBossFight = opponent.isBoss || false;
    
    // Track recent opponents if it's a real player
    if (opponent.isRealPlayer && opponent.fighterIdentifier) {
        if (!player.recentOpponents) {
            player.recentOpponents = [];
        }
        
        // Add to recent opponents list
        player.recentOpponents.push(opponent.fighterIdentifier);
        
        // Keep only the last 3 opponents
        if (player.recentOpponents.length > 3) {
            player.recentOpponents.shift(); // Remove the oldest
        }
        
        console.log('Updated recent opponents:', player.recentOpponents);
    }

    // Display opponent name with boss indicator
    var opponentDisplayName = opponent.name;
    if (opponent.isBoss) {
        opponentDisplayName = opponent.name + ' üíÄ (BOSS)';
    }
    
    document.getElementById('player1Name').textContent = player.name + ' (Level ' + player.level + ', ' + player.wins + ' wins)';
    document.getElementById('player2Name').textContent = opponentDisplayName + ' (Level ' + opponent.level + ', ' + opponent.wins + ' wins)';
    
    document.getElementById('player1HPText').textContent = Math.floor(player.currentHp) + '/' + player.maxHp;
    document.getElementById('player2HPText').textContent = Math.floor(opponent.currentHp) + '/' + opponent.maxHp;
    document.getElementById('player1HP').style.width = '100%';
    document.getElementById('player2HP').style.width = '100%';

    var fightLog = document.getElementById('fightLog');
    fightLog.innerHTML = '';

    if (opponent.isBoss) {
        addToFightLog('<div class="story-title" style="color: #ff0000; font-size: 1.3em;">üíÄ BOSS BATTLE üíÄ</div>');
        addToFightLog('<span style="color: #ff6b6b; font-weight: bold;">You have encountered a fearsome boss: ' + opponent.name + '!</span>');
    } else {
        addToFightLog('<div class="story-title">' + player.name + ' vs ' + opponent.name + '</div>');
    }
    addToFightLog('Fight begins!');
    
    setTimeout(function() { simulateFight(player, opponent); }, 1500);
}

        function addToFightLog(message) {
            var fightLog = document.getElementById('fightLog');
            var p = document.createElement('p');
            p.innerHTML = message;
            fightLog.appendChild(p);
            fightLog.scrollTop = fightLog.scrollHeight;
        }

        function simulateFight(player, opponent) {
    var turnCount = 1;
    var maxTurns = 100;
    currentBattleEvent = null; // Reset event for new fight
    
    function fightTurn() {
        // Check if fight is paused (for clash)
    if (fightPaused) {
        setTimeout(fightTurn, 100); // Check again in 100ms
        return;
    }
        if (turnCount > maxTurns || player.currentHp <= 0 || opponent.currentHp <= 0) {
            endCombat(player, opponent);
            return;
        }
        
        // Check for battle event trigger
if (shouldTriggerBattleEvent(turnCount, player, opponent)) {
    triggerBattleEvent(player, opponent);
            // Wait for event to resolve before continuing
            var checkResolved = setInterval(function() {
                if (currentBattleEvent && currentBattleEvent.resolved) {
                    clearInterval(checkResolved);
                    setTimeout(fightTurn, 1000); // Continue fight after event
                }
            }, 100);
            return;
        }
        
        // NERFED: Calculate speed-based extra attacks (0.5% per point instead of 1%)
        var playerSpeedChance = Math.min(50, (player.stats.speed - 1) * 0.5);
        var playerExtraAttack = Math.random() * 100 < playerSpeedChance;
        
        var opponentSpeedChance = Math.min(50, (opponent.stats.speed - 1) * 0.5);
        var opponentExtraAttack = Math.random() * 100 < opponentSpeedChance;
        
        // Player attacks first
        if (player.currentHp > 0) {
            performAttack(player, opponent, 'player');
            
            // Speed-based extra attack with visible notification
            if (playerExtraAttack && opponent.currentHp > 0) {
                setTimeout(function() {
                    addToFightLog('<span style="color: #b19cd9; font-weight: bold;">‚ö° SPEED BURST! ' + 
                        '<span class="player-name">' + player.name + '</span> attacks again! ‚ö°</span>');
                    performAttack(player, opponent, 'player');
                }, 400);
            }
        }
        
        // Check if opponent is defeated
        if (opponent.currentHp <= 0) {
            setTimeout(function() { endCombat(player, opponent); }, 1000);
            return;
        }
        
        // Small delay between attacks
        setTimeout(function() {
            // Opponent attacks
            if (opponent.currentHp > 0) {
                performAttack(opponent, player, 'opponent');
                
                // Opponent speed-based extra attack
                if (opponentExtraAttack && player.currentHp > 0) {
                    setTimeout(function() {
                        addToFightLog('<span style="color: #b19cd9; font-weight: bold;">‚ö° SPEED BURST! ' + 
                            '<span class="opponent-name">' + opponent.name + '</span> attacks again! ‚ö°</span>');
                        performAttack(opponent, player, 'opponent');
                    }, 400);
                }
            }
            
            // Check if player is defeated
            if (player.currentHp <= 0) {
                setTimeout(function() { endCombat(player, opponent); }, 1000);
                return;
            }
            
            turnCount++;
            setTimeout(fightTurn, 1500);
        }, 800);
    }
    
    fightTurn();
}
            
function performAttack(attacker, defender, attackerType) {
    // Check for event effects at the START of the attack
    var eventEffect = getEventEffect();
    var attackSource = null;
    var pendingEventEffect = null;

    // Event effects only apply when OPPONENT attacks PLAYER
    if (eventEffect && !eventEffect.applied && attackerType === 'opponent') {
        eventEffect.applied = true;
        currentBattleEvent.effectUsed = true;
        
        // If event uses an object, track it for later
        if (eventEffect.usesObject && eventEffect.objectName) {
            attackSource = eventEffect.objectName;
        }
        
        if (eventEffect.effect === 'avoided') {
            addToFightLog('<span class="dodge">‚ö° EVENT BONUS: ' + defender.name + ' avoided the ' + (attackSource || 'attack') + ' thanks to the event!</span>');
            return;
        } else if (eventEffect.effect === 'counter') {
            var counterDamage = Math.floor((10 + (defender.stats.strength - 1) * 2) * 1.5);
            
            if (defender.equipment && defender.equipment.weapon) {
                counterDamage += defender.equipment.weapon.power || 0;
            }
            
            attacker.currentHp = Math.max(0, attacker.currentHp - counterDamage);
            addToFightLog('<span style="color: #6bcf7f; font-weight: bold;">‚ö° EVENT BONUS: ' + defender.name + ' counters the ' + (attackSource || 'attack') + ' for <span class="damage">' + counterDamage + '</span> damage!</span>');
            
            var opponentHpPercent = (attacker.currentHp / attacker.maxHp) * 100;
            document.getElementById('player2HP').style.width = opponentHpPercent + '%';
            document.getElementById('player2HPText').textContent = Math.floor(attacker.currentHp) + '/' + attacker.maxHp;
            
            return;
        } else if (eventEffect.effect === 'reduced' || eventEffect.effect === 'increased') {
            pendingEventEffect = eventEffect.effect;
        }
    }
    
    // Check if special attack should be used BEFORE performing normal attack
    var shouldUseSpecial = false;

    if (attacker.level >= 10 && attacker.specialAttack && attacker.specialAvailable && !attacker.specialUsed) {
        if (attackerType === 'player' && attacker.useSpecialNext) {
            shouldUseSpecial = true;
            attacker.useSpecialNext = false;
            attacker.specialUsed = true;
            
            var btn = document.getElementById('player1SpecialBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = '‚ö° Special Used';
                btn.style.opacity = '0.5';
            }
        } else if (attackerType === 'opponent') {
            var ownHpPercent = (attacker.currentHp / attacker.maxHp) * 100;
            var opponentHpPercent = (defender.currentHp / defender.maxHp) * 100;
            
            if (ownHpPercent < 25) {
                console.log('Opponent using special attack (critical HP)!');
                shouldUseSpecial = true;
                attacker.specialUsed = true;
            } else {
                var useChance = 15;
                if (opponentHpPercent < 40) {
                    useChance = 40;
                } else if (ownHpPercent < 50) {
                    useChance = 25;
                }
                
                if (Math.random() * 100 < useChance) {
                    console.log('Opponent using special attack!');
                    shouldUseSpecial = true;
                    attacker.specialUsed = true;
                }
            }
        }
    }

    // If using special attack, do that instead of normal attack
if (shouldUseSpecial) {
    // Check if this is opponent using special and player can counter
    if (attackerType === 'opponent' && defender.level >= 10 && defender.specialAttack && 
        defender.specialAvailable && !defender.specialUsed) {
        
        // Store opponent reference for clash
        defender.currentOpponent = attacker;
        
        // Calculate damages for display
        var playerDamage = calculateSpecialDamage(defender, attacker);
        var opponentDamage = calculateSpecialDamage(attacker, defender);
        
        // Show clash prompt to player
        showSpecialClashPrompt(playerDamage, opponentDamage, defender.specialAttack.name, attacker.specialAttack.name);
        return; // Wait for player decision
    } 
    // Check if this is player using special and bot can counter (and bot's special is stronger)
    else if (attackerType === 'player' && defender.level >= 10 && defender.specialAttack && 
             defender.specialAvailable && !defender.specialUsed) {
        
        // Calculate damages to see if bot should counter
        var playerDamage = calculateSpecialDamage(attacker, defender);
        var opponentDamage = calculateSpecialDamage(defender, attacker);
        
        // Bot counters if their special is stronger
        if (opponentDamage > playerDamage) {
            console.log('Bot countering player special attack!');
            
            // Mark bot special as used
            defender.specialUsed = true;
            
            // Store player as opponent for clash
            attacker.currentOpponent = defender;
            
            // Add log message
            addToFightLog('<span style="color: #ff6b6b; font-weight: bold;">‚ö†Ô∏è ' + defender.name + ' counters with their own special attack!</span>');
            
            // Start clash immediately
            fightPaused = true;
            setTimeout(function() {
                startSpecialClash();
            }, 1000);
            return;
        } else {
            // Bot's special is weaker, let player's special go through
            performSpecialAttack(attacker, defender, attackerType);
            return;
        }
    } 
    else {
        // Normal special attack (no clash possible)
        performSpecialAttack(attacker, defender, attackerType);
        return;
    }
}
    
    var baseDamage = 10 + (attacker.stats.strength - 1) * 2;
    
    // Equipment bonus
    var weaponName = 'fists';
    var weaponRarity = 'common';
    if (attacker.equipment && attacker.equipment.weapon) {
        baseDamage += attacker.equipment.weapon.power || 0;
        weaponName = attacker.equipment.weapon.name || 'weapon';
        weaponRarity = attacker.equipment.weapon.rarity || 'common';
    }
    
    var weaponText = '<span class="' + weaponRarity + '">' + weaponName + '</span>';
    
    // Determine name classes
    var attackerNameClass = attackerType === 'player' ? 'player-name' : 'opponent-name';
    var defenderNameClass = attackerType === 'player' ? 'opponent-name' : 'player-name';
    var attackerNameText = '<span class="' + attackerNameClass + '">' + attacker.name + '</span>';
    var defenderNameText = '<span class="' + defenderNameClass + '">' + defender.name + '</span>';
    
    // Random damage variation (¬±25%)
    var damage = Math.floor(baseDamage * (0.75 + Math.random() * 0.5));
    
    // Dodge chance
    var dodgeChance = Math.min(35, (defender.stats.agility - 1) * 0.35);
    if (Math.random() * 100 < dodgeChance) {
        var dodgeTexts = ['sidesteps the attack', 'ducks under the blow', 'weaves away', 'rolls to safety', 'leaps back'];
        var dodgeText = dodgeTexts[Math.floor(Math.random() * dodgeTexts.length)];
        addToFightLog('<span class="dodge">' + defenderNameText + ' ' + dodgeText + '!</span>');
        return;
    }
    
    // Critical hit chance
    var critChance = Math.min(50, (attacker.stats.luck - 1) * 0.5);
    var isCrit = Math.random() * 100 < critChance;
    
    // Calculate defense from armor only
    var totalDefense = 0;
    if (defender.equipment) {
        var equipmentSlotNames = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
        for (var i = 0; i < equipmentSlotNames.length; i++) {
            var slot = equipmentSlotNames[i];
            var item = defender.equipment[slot];
            if (item && item.statType === 'Defense') {
                totalDefense += item.power || 0;
            }
        }
    }
    
    // Defense reduction from armor (capped at 60%)
    var defenseReduction = Math.min(60, totalDefense * 0.25);
    damage = Math.floor(damage * (1 - defenseReduction / 100));

    // Apply event effect modifiers for damage reduction/increase
    // This must happen BEFORE toughness check
    if (pendingEventEffect && attackerType === 'opponent') {
        var originalDamage = damage;
        
        if (pendingEventEffect === 'reduced') {
            damage = Math.floor(damage * 0.5); // Take 50% less damage
            var damageReduced = originalDamage - damage;
            addToFightLog('<span style="color: #6bcf7f;">‚ö° EVENT BONUS: Damage reduced by ' + damageReduced + '! (From ' + originalDamage + ' to ' + damage + ')</span>');
        } else if (pendingEventEffect === 'increased') {
            damage = Math.floor(damage * 1.5); // Take 50% more damage
            var damageIncreased = damage - originalDamage;
            addToFightLog('<span style="color: #ff6b6b;">‚ùå EVENT PENALTY: Damage increased by ' + damageIncreased + '! (From ' + originalDamage + ' to ' + damage + ')</span>');
        }
    }

    // Toughness check - chance to reduce damage by 50%
    var toughnessChance = Math.min(50, (defender.stats.toughness - 1) * 0.5);
    var toughnessProc = Math.random() * 100 < toughnessChance;
    
    if (toughnessProc) {
        damage = Math.floor(damage * 0.5); // 50% damage reduction when it procs
        addToFightLog('<span style="color: #4ecdc4; font-weight: bold;">üõ°Ô∏è TOUGH! ' + defenderNameText + ' braces for impact and reduces damage by 50%!</span>');
    }
    
    damage = Math.max(1, damage);
    
    var attackText = '';
    
    // Determine what weapon/object was used
    var displayWeapon;
    if (attackSource) {
        // Event object (rock, knife, etc.)
        displayWeapon = '<span class="uncommon">' + attackSource + '</span>';
    } else {
        // Regular weapon
        displayWeapon = weaponText;
    }

    if (isCrit) {
        damage = Math.floor(damage * 2.0);
        damage = Math.max(2, damage);
        // Enhanced critical hit display
        var critTexts = [
            '<span class="critical-hit-text">‚ö° CRITICAL HIT! ‚ö°</span> ' + attackerNameText + ' finds a weak spot with their ' + displayWeapon + ' and deals <span class="damage">' + damage + '</span> massive damage!',
            '<span class="critical-hit-text">üí• CRITICAL STRIKE! üí•</span> ' + attackerNameText + ' lands a devastating blow with their ' + displayWeapon + ' for <span class="damage">' + damage + '</span> damage!',
            '<span class="critical-hit-text">üî• CRITICAL! üî•</span> ' + attackerNameText + '\'s ' + displayWeapon + ' strikes true for <span class="damage">' + damage + '</span> crushing damage!'
        ];
        attackText = critTexts[Math.floor(Math.random() * critTexts.length)];
    } else {
        // Regular attacks with highlighted names
        var bodyParts = ['chest', 'shoulder', 'arm', 'leg', 'ribs', 'side', 'back'];
        var painSounds = ['grunts in pain', 'winces', 'staggers', 'reels back', 'stumbles'];
        
        var attackVariations = [
            attackerNameText + ' strikes with their ' + displayWeapon + ', dealing <span class="damage">' + damage + '</span> damage to ' + defenderNameText + '!',
            attackerNameText + '\'s ' + displayWeapon + ' hits ' + defenderNameText + '\'s ' + bodyParts[Math.floor(Math.random() * bodyParts.length)] + ' for <span class="damage">' + damage + '</span> damage!',
            defenderNameText + ' ' + painSounds[Math.floor(Math.random() * painSounds.length)] + ' as ' + attackerNameText + '\'s ' + displayWeapon + ' connects for <span class="damage">' + damage + '</span> damage!'
        ];
        attackText = attackVariations[Math.floor(Math.random() * attackVariations.length)];
    }
    
    defender.currentHp = Math.max(0, defender.currentHp - damage);
    
    addToFightLog(attackText);
    
    // Update HP bars
    if (attackerType === 'player') {
        var opponentHpPercent = (defender.currentHp / defender.maxHp) * 100;
        document.getElementById('player2HP').style.width = opponentHpPercent + '%';
        document.getElementById('player2HPText').textContent = Math.floor(defender.currentHp) + '/' + defender.maxHp;
    } else {
        var playerHpPercent = (defender.currentHp / defender.maxHp) * 100;
        document.getElementById('player1HP').style.width = playerHpPercent + '%';
        document.getElementById('player1HPText').textContent = Math.floor(defender.currentHp) + '/' + defender.maxHp;
    }
}

function playerUseSpecial() {
    var player = gameState.currentFighter;
    if (!player.specialAvailable || player.specialUsed) {
        console.log('Special not available or already used');
        return;
    }
    
    console.log('Special attack queued for next player turn');
    
    // Mark special as queued (will be used on next player attack)
    player.useSpecialNext = true;
    
    // Disable button immediately
    var btn = document.getElementById('player1SpecialBtn');
    if (btn) {
        btn.disabled = true;
        btn.textContent = '‚ö° Special Queued...';
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
    }
}
            
            function performSpecialAttack(attacker, defender, attackerType) {
    if (defender.currentHp <= 0) return;

    // Add this at the beginning to show opponent used their special
    if (attackerType === 'opponent') {
        addToFightLog('<span style="color: #ff6b6b; font-weight: bold;">‚ö†Ô∏è ' + attacker.name + ' prepares their special attack!</span>');
    }
    
    // Calculate special attack damage - NO STRENGTH BONUS
    var specialDamage = attacker.level * 4 + 20;
    
    if (attacker.equipment && attacker.equipment.weapon) {
        specialDamage += attacker.equipment.weapon.power || 0;
    }
    
    specialDamage = Math.floor(specialDamage * (0.85 + Math.random() * 0.3));
    
    // Calculate defense from armor
    var totalDefense = 0;
    if (defender.equipment) {
        var equipmentSlotNames = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
        for (var i = 0; i < equipmentSlotNames.length; i++) {
            var slot = equipmentSlotNames[i];
            var item = defender.equipment[slot];
            if (item && item.statType === 'Defense') {
                totalDefense += item.power || 0;
            }
        }
    }
    
    var defenseReduction = Math.min(60, totalDefense * 0.25);
    specialDamage = Math.floor(specialDamage * (1 - defenseReduction / 100));
    
    // Toughness check
    var toughnessChance = Math.min(50, (defender.stats.toughness - 1) * 0.5);
    var toughnessProc = Math.random() * 100 < toughnessChance;
    
    if (toughnessProc) {
        specialDamage = Math.floor(specialDamage * 0.5);
        var defenderNameClass = attackerType === 'player' ? 'opponent-name' : 'player-name';
        var defenderNameText = '<span class="' + defenderNameClass + '">' + defender.name + '</span>';
        addToFightLog('<span style="color: #4ecdc4; font-weight: bold;">üõ°Ô∏è TOUGH! ' + defenderNameText + ' braces for impact and reduces damage by 50%!</span>');
    }
    
    specialDamage = Math.max(3, specialDamage);
    
    defender.currentHp = Math.max(0, defender.currentHp - specialDamage);
    
    // Determine name classes
    var attackerNameClass = attackerType === 'player' ? 'player-name' : 'opponent-name';
    var defenderNameClass = attackerType === 'player' ? 'opponent-name' : 'player-name';
    var attackerNameText = '<span class="' + attackerNameClass + '">' + attacker.name + '</span>';
    var defenderNameText = '<span class="' + defenderNameClass + '">' + defender.name + '</span>';
    
    // Enhanced special attack display
    var specialTexts = [
        '<span class="special-attack-text">‚≠ê SPECIAL ATTACK! ‚≠ê</span><br>' + 
        attackerNameText + ' channels their energy and unleashes <span class="special">' + attacker.specialAttack.name + '</span> for <span class="damage">' + specialDamage + '</span> devastating damage!',
        
        '<span class="special-attack-text">‚ú® ULTIMATE MOVE! ‚ú®</span><br>' +
        'With a battle cry, ' + attackerNameText + ' executes their signature move <span class="special">' + attacker.specialAttack.name + '</span> dealing <span class="damage">' + specialDamage + '</span> damage!',
        
        '<span class="special-attack-text">üí´ SPECIAL TECHNIQUE! üí´</span><br>' +
        attackerNameText + ' focuses their power and strikes with <span class="special">' + attacker.specialAttack.name + '</span> - ' + defenderNameText + ' reels from the <span class="damage">' + specialDamage + '</span> damage!'
    ];
    
    addToFightLog(specialTexts[Math.floor(Math.random() * specialTexts.length)]);
    
    // Update HP bars
    if (attackerType === 'player') {
        var opponentHpPercent = (defender.currentHp / defender.maxHp) * 100;
        document.getElementById('player2HP').style.width = opponentHpPercent + '%';
        document.getElementById('player2HPText').textContent = Math.floor(defender.currentHp) + '/' + defender.maxHp;
    } else {
        var playerHpPercent = (defender.currentHp / defender.maxHp) * 100;
        document.getElementById('player1HP').style.width = playerHpPercent + '%';
        document.getElementById('player1HPText').textContent = Math.floor(defender.currentHp) + '/' + defender.maxHp;
    }
}   

function showSpecialClashPrompt(playerDamage, opponentDamage, playerSpecialName, opponentSpecialName) {
    clashTimeLeft = 10;
    fightPaused = true; // PAUSE THE FIGHT
    
    var modalHTML = 
        '<div id="clashPromptModal" class="clash-modal">' +
            '<div class="clash-container">' +
                '<div class="clash-title">‚ö° SPECIAL ATTACK CLASH! ‚ö°</div>' +
                '<div class="clash-timer">Counter in: <span id="clashTimerCount">' + clashTimeLeft + '</span>s</div>' +
                
                '<div class="clash-info">' +
                    '<p style="color: #fff; text-align: center; margin-bottom: 15px; font-size: 1.1em;">' +
                        'Your opponent is using their special attack!' +
                    '</p>' +
                    '<p style="color: #ffd93d; text-align: center; font-size: 0.95em;">' +
                        'Counter with your own special attack to clash!' +
                    '</p>' +
                '</div>' +
                
                '<div class="clash-fighters">' +
                    '<div class="clash-fighter">' +
                        '<div class="clash-fighter-name">You</div>' +
                        '<div class="clash-attack-name">' + playerSpecialName + '</div>' +
                    '</div>' +
                    '<div class="clash-vs">VS</div>' +
                    '<div class="clash-fighter">' +
                        '<div class="clash-fighter-name" style="color: #ff6b6b;">Opponent</div>' +
                        '<div class="clash-attack-name">' + opponentSpecialName + '</div>' +
                    '</div>' +
                '</div>' +
                
                '<div style="display: flex; gap: 15px; margin-top: 25px;">' +
                    '<button class="btn btn-primary" onclick="acceptSpecialClash()" style="flex: 1; padding: 15px; font-size: 1.2em; font-weight: bold;">‚ö° COUNTER!</button>' +
                    '<button class="btn btn-secondary" onclick="declineSpecialClash()" style="flex: 1; padding: 15px;">Defend</button>' +
                '</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Start countdown timer
    clashTimer = setInterval(function() {
        clashTimeLeft--;
        var timerElement = document.getElementById('clashTimerCount');
        if (timerElement) {
            timerElement.textContent = clashTimeLeft;
        }
        
        if (clashTimeLeft <= 0) {
            clearInterval(clashTimer);
            declineSpecialClash();
        }
    }, 1000);
}

function acceptSpecialClash() {
    clearInterval(clashTimer);
    var modal = document.getElementById('clashPromptModal');
    if (modal) {
        modal.remove();
    }
    
    // Mark player special as used
    gameState.currentFighter.specialUsed = true;
    var btn = document.getElementById('player1SpecialBtn');
    if (btn) {
        btn.disabled = true;
        btn.textContent = '‚ö° Special Used';
        btn.style.opacity = '0.5';
    }
    
    // Start the clash animation
    startSpecialClash();
}

function declineSpecialClash() {
    clearInterval(clashTimer);
    var modal = document.getElementById('clashPromptModal');
    if (modal) {
        modal.remove();
    }
    
    // Opponent's special attack goes through normally
    continueOpponentSpecial();
    
    // RESUME THE FIGHT
    fightPaused = false;
}
function startSpecialClash() {
    var player = gameState.currentFighter;
    var opponent = player.currentOpponent;
    
    // Calculate both special attack damages
    var playerDamage = calculateSpecialDamage(player, opponent);
    var opponentDamage = calculateSpecialDamage(opponent, player);
    
    var modalHTML = 
        '<div id="clashAnimationModal" class="clash-modal">' +
            '<div class="clash-container clashing">' +
                '<div class="clash-title">‚öîÔ∏è CLASH IN PROGRESS! ‚öîÔ∏è</div>' +
                
                '<div class="clash-fighters" style="margin-bottom: 30px;">' +
                    '<div class="clash-fighter">' +
                        '<div class="clash-fighter-name">' + player.name + '</div>' +
                        '<div class="clash-attack-name">' + player.specialAttack.name + '</div>' +
                    '</div>' +
                    '<div class="clash-vs">‚öîÔ∏è</div>' +
                    '<div class="clash-fighter">' +
                        '<div class="clash-fighter-name" style="color: #ff6b6b;">' + opponent.name + '</div>' +
                        '<div class="clash-attack-name">' + opponent.specialAttack.name + '</div>' +
                    '</div>' +
                '</div>' +
                
                '<div class="clash-bar-container">' +
                    '<div class="clash-bar clash-bar-player" id="clashBarPlayer" style="width: 50%;"></div>' +
                    '<div class="clash-bar clash-bar-opponent" id="clashBarOpponent" style="width: 50%;"></div>' +
                    '<div class="clash-center-line"></div>' +
                '</div>' +
                
                '<div style="text-align: center; color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-top: 20px;">The stronger attack will prevail!</div>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Animate the clash bars
    animateClash(playerDamage, opponentDamage);
}

function animateClash(playerDamage, opponentDamage) {
    var playerBar = document.getElementById('clashBarPlayer');
    var opponentBar = document.getElementById('clashBarOpponent');
    
    if (!playerBar || !opponentBar) return;
    
    var totalDamage = playerDamage + opponentDamage;
    var playerPercent = (playerDamage / totalDamage) * 100;
    var opponentPercent = (opponentDamage / totalDamage) * 100;
    
    // Determine who wins
    var playerWins = playerDamage > opponentDamage;
    
    // Generate random animation pattern (5 different patterns)
    var pattern = Math.floor(Math.random() * 5);
    var animationPhases = [];
    
    if (pattern === 0) {
        // Pattern 1: Player dominates early, opponent fights back, winner emerges
        animationPhases = [
            { player: 50, opponent: 50, delay: 100 },
            { player: 60, opponent: 40, delay: 500 },
            { player: 75, opponent: 25, delay: 1000 },
            { player: 85, opponent: 15, delay: 1500 },
            { player: 90, opponent: 10, delay: 2000 },
            { player: 80, opponent: 20, delay: 2500 },
            { player: 65, opponent: 35, delay: 3000 },
            { player: 45, opponent: 55, delay: 3500 },
            { player: 30, opponent: 70, delay: 4000 },
            { player: 20, opponent: 80, delay: 4500 },
            { player: playerWins ? 35 : 10, opponent: playerWins ? 65 : 90, delay: 5000 },
            { player: playerWins ? 55 : 5, opponent: playerWins ? 45 : 95, delay: 5500 },
            { player: playerWins ? 75 : 2, opponent: playerWins ? 25 : 98, delay: 6000 },
            { player: playerWins ? 90 : 1, opponent: playerWins ? 10 : 99, delay: 6500 },
            { player: playerWins ? 100 : 0, opponent: playerWins ? 0 : 100, delay: 7000 }
        ];
    } else if (pattern === 1) {
        // Pattern 2: Opponent dominates early, player fights back, winner emerges
        animationPhases = [
            { player: 50, opponent: 50, delay: 100 },
            { player: 40, opponent: 60, delay: 500 },
            { player: 25, opponent: 75, delay: 1000 },
            { player: 15, opponent: 85, delay: 1500 },
            { player: 10, opponent: 90, delay: 2000 },
            { player: 20, opponent: 80, delay: 2500 },
            { player: 35, opponent: 65, delay: 3000 },
            { player: 55, opponent: 45, delay: 3500 },
            { player: 70, opponent: 30, delay: 4000 },
            { player: 80, opponent: 20, delay: 4500 },
            { player: playerWins ? 70 : 25, opponent: playerWins ? 30 : 75, delay: 5000 },
            { player: playerWins ? 80 : 15, opponent: playerWins ? 20 : 85, delay: 5500 },
            { player: playerWins ? 90 : 8, opponent: playerWins ? 10 : 92, delay: 6000 },
            { player: playerWins ? 95 : 3, opponent: playerWins ? 5 : 97, delay: 6500 },
            { player: playerWins ? 100 : 0, opponent: playerWins ? 0 : 100, delay: 7000 }
        ];
    } else if (pattern === 2) {
        // Pattern 3: Even back and forth, sudden winner emergence
        animationPhases = [
            { player: 50, opponent: 50, delay: 100 },
            { player: 60, opponent: 40, delay: 500 },
            { player: 55, opponent: 45, delay: 900 },
            { player: 45, opponent: 55, delay: 1300 },
            { player: 40, opponent: 60, delay: 1700 },
            { player: 50, opponent: 50, delay: 2100 },
            { player: 60, opponent: 40, delay: 2500 },
            { player: 50, opponent: 50, delay: 2900 },
            { player: 40, opponent: 60, delay: 3300 },
            { player: 50, opponent: 50, delay: 3700 },
            { player: 55, opponent: 45, delay: 4100 },
            { player: 45, opponent: 55, delay: 4500 },
            { player: playerWins ? 60 : 35, opponent: playerWins ? 40 : 65, delay: 4900 },
            { player: playerWins ? 80 : 20, opponent: playerWins ? 20 : 80, delay: 5300 },
            { player: playerWins ? 95 : 5, opponent: playerWins ? 5 : 95, delay: 5700 },
            { player: playerWins ? 100 : 0, opponent: playerWins ? 0 : 100, delay: 6100 }
        ];
    } else if (pattern === 3) {
        // Pattern 4: Slow grind, one side slowly dominates
        animationPhases = [
            { player: 50, opponent: 50, delay: 100 },
            { player: 55, opponent: 45, delay: 600 },
            { player: 60, opponent: 40, delay: 1200 },
            { player: 58, opponent: 42, delay: 1800 },
            { player: 53, opponent: 47, delay: 2400 },
            { player: 48, opponent: 52, delay: 3000 },
            { player: 43, opponent: 57, delay: 3600 },
            { player: 40, opponent: 60, delay: 4200 },
            { player: playerWins ? 45 : 35, opponent: playerWins ? 55 : 65, delay: 4800 },
            { player: playerWins ? 55 : 28, opponent: playerWins ? 45 : 72, delay: 5400 },
            { player: playerWins ? 70 : 18, opponent: playerWins ? 30 : 82, delay: 6000 },
            { player: playerWins ? 85 : 8, opponent: playerWins ? 15 : 92, delay: 6600 },
            { player: playerWins ? 100 : 0, opponent: playerWins ? 0 : 100, delay: 7200 }
        ];
    } else {
        // Pattern 5: Explosive start, calm middle, dramatic finish
        animationPhases = [
            { player: 50, opponent: 50, delay: 100 },
            { player: 75, opponent: 25, delay: 400 },
            { player: 30, opponent: 70, delay: 800 },
            { player: 65, opponent: 35, delay: 1200 },
            { player: 40, opponent: 60, delay: 1600 },
            { player: 48, opponent: 52, delay: 2000 },
            { player: 52, opponent: 48, delay: 2400 },
            { player: 50, opponent: 50, delay: 2800 },
            { player: 48, opponent: 52, delay: 3200 },
            { player: 52, opponent: 48, delay: 3600 },
            { player: playerWins ? 60 : 40, opponent: playerWins ? 40 : 60, delay: 4000 },
            { player: playerWins ? 75 : 25, opponent: playerWins ? 25 : 75, delay: 4400 },
            { player: playerWins ? 88 : 12, opponent: playerWins ? 12 : 88, delay: 4800 },
            { player: playerWins ? 96 : 4, opponent: playerWins ? 4 : 96, delay: 5200 },
            { player: playerWins ? 100 : 0, opponent: playerWins ? 0 : 100, delay: 5600 }
        ];
    }
    
    // Animate through each phase
    animationPhases.forEach(function(phase) {
        setTimeout(function() {
            if (playerBar && opponentBar) {
                playerBar.style.width = phase.player + '%';
                opponentBar.style.width = phase.opponent + '%';
                
                // Add extra shake effect during big pushes
                var container = document.querySelector('.clash-container');
                if (container && (phase.player >= 80 || phase.opponent >= 80)) {
                    container.classList.add('clashing');
                } else if (container) {
                    container.classList.remove('clashing');
                }
            }
        }, phase.delay);
    });
    
    // After animation completes, resolve the clash
    var finalDelay = animationPhases[animationPhases.length - 1].delay + 500;
    setTimeout(function() {
        resolveSpecialClash(playerDamage, opponentDamage);
    }, finalDelay);
}

function resolveSpecialClash(playerDamage, opponentDamage) {
    var modal = document.getElementById('clashAnimationModal');
    if (modal) {
        modal.remove();
    }
    
    var player = gameState.currentFighter;
    var opponent = player.currentOpponent;
    
    if (playerDamage > opponentDamage) {
        // Player wins clash - deal FULL player special damage to opponent
        opponent.currentHp = Math.max(0, opponent.currentHp - playerDamage);
        
        addToFightLog('<span style="color: #6bcf7f; font-size: 1.2em; font-weight: bold;">‚ö° CLASH VICTORY! ‚ö°</span>');
        addToFightLog('<span class="player-name">' + player.name + '</span>\'s <span class="special">' + player.specialAttack.name + '</span> overpowers <span class="opponent-name">' + opponent.name + '</span>\'s <span class="special">' + opponent.specialAttack.name + '</span>!');
        addToFightLog('<span class="opponent-name">' + opponent.name + '</span> takes <span class="damage">' + playerDamage + '</span> damage from the clash!');
        
        // Update opponent HP
        var opponentHpPercent = (opponent.currentHp / opponent.maxHp) * 100;
        document.getElementById('player2HP').style.width = opponentHpPercent + '%';
        document.getElementById('player2HPText').textContent = Math.floor(opponent.currentHp) + '/' + opponent.maxHp;
        
    } else if (opponentDamage > playerDamage) {
        // Opponent wins clash - deal FULL opponent special damage to player
        player.currentHp = Math.max(0, player.currentHp - opponentDamage);
        
        addToFightLog('<span style="color: #ff6b6b; font-size: 1.2em; font-weight: bold;">‚öîÔ∏è CLASH DEFEAT! ‚öîÔ∏è</span>');
        addToFightLog('<span class="opponent-name">' + opponent.name + '</span>\'s <span class="special">' + opponent.specialAttack.name + '</span> overpowers <span class="player-name">' + player.name + '</span>\'s <span class="special">' + player.specialAttack.name + '</span>!');
        addToFightLog('<span class="player-name">' + player.name + '</span> takes <span class="damage">' + opponentDamage + '</span> damage from the clash!');
        
        // Update player HP
        var playerHpPercent = (player.currentHp / player.maxHp) * 100;
        document.getElementById('player1HP').style.width = playerHpPercent + '%';
        document.getElementById('player1HPText').textContent = Math.floor(player.currentHp) + '/' + player.maxHp;
        
    } else {
        // Perfect tie - no damage
        addToFightLog('<span style="color: #ffd93d; font-size: 1.2em; font-weight: bold;">‚öñÔ∏è PERFECT CLASH! ‚öñÔ∏è</span>');
        addToFightLog('Both special attacks are perfectly matched! The attacks cancel each other out - no damage dealt!');
    }
    
    // Clear opponent reference
    player.currentOpponent = null;
    
    // RESUME THE FIGHT
    fightPaused = false;
}
function calculateSpecialDamage(attacker, defender) {
    var specialDamage = attacker.level * 4 + 20;
    
    if (attacker.equipment && attacker.equipment.weapon) {
        specialDamage += attacker.equipment.weapon.power || 0;
    }
    
    // Apply defense
    var totalDefense = 0;
    if (defender.equipment) {
        var equipmentSlotNames = ['offhand', 'helmet', 'shoulders', 'gloves', 'chest', 'greaves', 'boots'];
        for (var i = 0; i < equipmentSlotNames.length; i++) {
            var slot = equipmentSlotNames[i];
            var item = defender.equipment[slot];
            if (item && item.statType === 'Defense') {
                totalDefense += item.power || 0;
            }
        }
    }
    
    var defenseReduction = Math.min(60, totalDefense * 0.25);
    specialDamage = Math.floor(specialDamage * (1 - defenseReduction / 100));
    
    return Math.max(3, specialDamage);
}

function continueOpponentSpecial() {
    // This is called when player declines to clash or time runs out
    // The opponent's special attack continues normally
    var player = gameState.currentFighter;
    var opponent = player.currentOpponent;
    
    if (opponent && opponent.currentHp > 0) {
        performSpecialAttack(opponent, player, 'opponent');
    }
    
    // Clear opponent reference
    player.currentOpponent = null;
    
    // RESUME THE FIGHT
    fightPaused = false;
}
            
            function endCombat(player, opponent) {
    var playerWon = player.currentHp > 0;

    // Store battle result BEFORE restoring HP
    player.didLoseBossFight = !playerWon && (player.isBossFight || false);
                
    // Increment total fights counter
    if (player.totalFights === undefined) {
        player.totalFights = 0;
    }
    player.totalFights++;
    
    if (playerWon) {
        // Reset loss streak on win
        player.lossStreak = 0;
        
        var victoryTexts = [
            '<span class="victory">üéâ ' + player.name + ' emerges victorious from the battle! üéâ</span>',
            '<span class="victory">üéâ Victory belongs to ' + player.name + '! üéâ</span>',
            '<span class="victory">üéâ ' + player.name + ' stands triumphant over their fallen opponent! üéâ</span>',
            '<span class="victory">üéâ ' + player.name + ' proves their superiority in combat! üéâ</span>'
        ];
        addToFightLog(victoryTexts[Math.floor(Math.random() * victoryTexts.length)]);
        
        // Award experience (always)
        var expGained = Math.floor(20 + opponent.level * 5);
        player.exp += expGained;
        player.wins++;

        // Track daily wins for tasks (account-wide now)
        incrementDailyWins();
        
        // IMPORTANT: Save immediately after incrementing wins to prevent loss
        saveToSupabase();
        
        // Track weekly wins AFTER saving global wins
        incrementWeeklyWins(player);
        saveWeeklyWin(player.name);
        
        addToFightLog('<span class="exp-gain">Gained ' + expGained + ' EXP!</span>');

// Boss loot - guaranteed Legendary or Mythic
if (player.isBossFight) {
    var isMythic = Math.random() * 100 < 30; // 30% chance for Mythic, 70% for Legendary
    var bossLoot = generateBossLoot(player, opponent.level, isMythic);
    
    if (bossLoot) {
        var itemLevelText = bossLoot.itemLevel ? 'Lv.' + bossLoot.itemLevel + ' ' : '';
        var rarityText = bossLoot.rarity ? ' (' + bossLoot.rarity.charAt(0).toUpperCase() + bossLoot.rarity.slice(1) + ')' : '';
        
        addToFightLog('<span class="' + bossLoot.rarity + '" style="font-size: 1.2em;">üéÅ BOSS DEFEATED! ' + 
            opponent.name + ' dropped: ' + 
            itemLevelText + bossLoot.name + rarityText + 
            ' (+' + bossLoot.power + ' ' + bossLoot.statType + ')!</span>');
        
        player.pendingLoot = bossLoot;
    }
} else {
    // Regular equipment drop
    var equipmentDropChance = 25;
    if (Math.random() * 100 < equipmentDropChance) {
        var isUpgrade = Math.random() * 100 < 60;
        var droppedItem = generateLootItem(player, opponent.level, isUpgrade);
        
        if (droppedItem) {
            var itemLevelText = droppedItem.itemLevel ? 'Lv.' + droppedItem.itemLevel + ' ' : '';
            var rarityText = droppedItem.rarity ? ' (' + droppedItem.rarity.charAt(0).toUpperCase() + droppedItem.rarity.slice(1) + ')' : '';
            
            addToFightLog('<span class="' + droppedItem.rarity + '">üéÅ ' + opponent.name + ' dropped: ' + 
                itemLevelText + droppedItem.name + rarityText + 
                ' (+' + droppedItem.power + ' ' + droppedItem.statType + ')!</span>');
            
            player.pendingLoot = droppedItem;
        }
    }
}
        
    } else {
    // Loss handling...
    if (player.lossStreak === undefined) {
        player.lossStreak = 0;
    }
    player.lossStreak++;
    
    var defeatTexts = [
        '<span class="defeat">üíÄ ' + player.name + ' has been defeated in battle! üíÄ</span>',
        '<span class="defeat">üíÄ ' + player.name + ' falls to their opponent! üíÄ</span>',
        '<span class="defeat">üíÄ ' + opponent.name + ' proves too strong for ' + player.name + '! üíÄ</span>',
        '<span class="defeat">üíÄ ' + player.name + ' fought valiantly but could not prevail! üíÄ</span>'
    ];
    addToFightLog(defeatTexts[Math.floor(Math.random() * defeatTexts.length)]);
    
    var consolationExp = Math.floor(5 + opponent.level);
    player.exp += consolationExp;
    addToFightLog('<span class="exp-gain">Gained ' + consolationExp + ' consolation EXP for the effort!</span>');
    
    // Store boss data if this was a boss fight (for rematch option)
    if (player.isBossFight) {
        gameState.currentBoss = opponent;
    }
}
    
    // Check for level up
    while (player.exp >= player.expRequired) {
        levelUp(player);
    }
    
    // Restore player HP
    player.hp = player.maxHp;
    player.currentHp = player.maxHp;
    
    // Final save after all changes
    saveToSupabase();
    document.getElementById('endFightBtn').style.display = 'block';
}
            
            function generateLootItem(player, opponentLevel, isUpgrade) {
    var itemTypes = [
        { 
            slot: 'weapon', 
            statType: 'Damage', 
            names: [
                'Sword', 'Axe', 'Mace', 'Spear', 'Dagger', 'Hammer', 'Staff', 'Blade',
                'Cleaver', 'Scimitar', 'Katana', 'Rapier', 'Saber', 'Falchion', 'Claymore',
                'Halberd', 'Glaive', 'Pike', 'Trident', 'Lance', 'Javelin',
                'Warhammer', 'Maul', 'Flail', 'Morning Star', 'Club', 'Cudgel',
                'Scythe', 'Sickle', 'Whip', 'Chain', 'Knuckles', 'Gauntlet',
                'Bow', 'Crossbow', 'Longbow', 'Shortbow',
                'Wand', 'Rod', 'Scepter', 'Orb', 'Tome', 'Grimoire'
            ]
        },
        { 
            slot: 'helmet', 
            statType: 'Defense', 
            names: [
                'Helmet', 'Crown', 'Cap', 'Hood', 'Circlet', 'Mask', 'Headband',
                'Helm', 'Casque', 'Coif', 'Cowl', 'Visor', 'Diadem', 'Tiara',
                'Skullcap', 'Bascinet', 'Sallet', 'Barbute', 'Armet', 'Great Helm',
                'Bandana', 'Turban', 'Headdress', 'Coronet'
            ]
        },
        { 
            slot: 'chest', 
            statType: 'Defense', 
            names: [
                'Armor', 'Vest', 'Robe', 'Tunic', 'Mail', 'Plate', 'Garb',
                'Breastplate', 'Cuirass', 'Hauberk', 'Brigandine', 'Doublet',
                'Chainmail', 'Chestplate', 'Jerkin', 'Surcoat', 'Tabard',
                'Cloak', 'Mantle', 'Vestment', 'Harness', 'Coat'
            ]
        },
        { 
            slot: 'gloves', 
            statType: 'Defense', 
            names: [
                'Gloves', 'Gauntlets', 'Mitts', 'Wraps', 'Grips',
                'Handguards', 'Vambraces', 'Bracers', 'Cuffs', 'Handwraps',
                'Mittens', 'Fists', 'Cestus', 'Knuckle Guards'
            ]
        },
        { 
            slot: 'boots', 
            statType: 'Defense', 
            names: [
                'Boots', 'Shoes', 'Sandals', 'Greaves', 'Treads',
                'Sabatons', 'Sollerets', 'Footguards', 'Slippers', 'Moccasins',
                'Stompers', 'Walkers', 'Striders', 'Runners', 'Leggings'
            ]
        },
        { 
            slot: 'offhand', 
            statType: 'Defense', 
            names: [
                'Shield', 'Buckler', 'Guard', 'Protector', 'Ward',
                'Targe', 'Pavise', 'Scutum', 'Heater', 'Kite Shield',
                'Tower Shield', 'Round Shield', 'Aspis', 'Parma', 'Deflector'
            ]
        },
        { 
            slot: 'shoulders', 
            statType: 'Defense', 
            names: [
                'Pauldrons', 'Guards', 'Plates', 'Pads',
                'Spaulders', 'Shoulderguards', 'Mantle', 'Epaulettes',
                'Reinforcements', 'Protectors', 'Shields'
            ]
        },
        { 
            slot: 'greaves', 
            statType: 'Defense', 
            names: [
                'Greaves', 'Guards', 'Plates', 'Protectors',
                'Shin Guards', 'Leg Armor', 'Leggings', 'Cuisses',
                'Poleyns', 'Leg Plates', 'Shinguards'
            ]
        }
    ];
    
    var upgradeableSlots = [];
    
    for (var i = 0; i < itemTypes.length; i++) {
        var itemType = itemTypes[i];
        var currentItem = player.equipment[itemType.slot];
        
        if (!currentItem) {
            upgradeableSlots.push({
                type: itemType,
                currentPower: 0,
                currentItemLevel: 0,
                priority: 100
            });
        } else {
            upgradeableSlots.push({
                type: itemType,
                currentPower: currentItem.power || 0,
                currentItemLevel: currentItem.itemLevel || 1,
                priority: 50 - (currentItem.power || 0)
            });
        }
    }
    
    upgradeableSlots.sort(function(a, b) {
        if (a.priority !== b.priority) {
            return b.priority - a.priority;
        }
        return a.currentPower - b.currentPower;
    });
    
    // Select from top 3 prioritized slots
    var topSlots = upgradeableSlots.slice(0, Math.min(3, upgradeableSlots.length));
    var selectedSlot = topSlots[Math.floor(Math.random() * topSlots.length)];
    var itemType = selectedSlot.type;
    var currentItem = player.equipment[itemType.slot];
    
    // Item level based on opponent
    var itemLevel = Math.max(1, opponentLevel + Math.floor(Math.random() * 5) - 2);
    
    // Determine rarity based on upgrade/downgrade
var rarities;

if (isUpgrade) {
    // Upgrade: same or higher rarity
    if (itemLevel <= 5) {
        rarities = [
            { name: 'common', weight: 50, powerPerLevel: 2, prefix: '' },
            { name: 'uncommon', weight: 35, powerPerLevel: 2.5, prefix: 'Fine ' },
            { name: 'rare', weight: 15, powerPerLevel: 3, prefix: 'Superior ' }
        ];
    } else if (itemLevel <= 15) {
        rarities = [
            { name: 'uncommon', weight: 40, powerPerLevel: 2.5, prefix: 'Fine ' },
            { name: 'rare', weight: 35, powerPerLevel: 3, prefix: 'Superior ' },
            { name: 'epic', weight: 20, powerPerLevel: 3.5, prefix: 'Masterwork ' },
            { name: 'legendary', weight: 5, powerPerLevel: 4, prefix: 'Legendary ' }
        ];
    } else if (itemLevel <= 30) {
        rarities = [
            { name: 'rare', weight: 35, powerPerLevel: 3, prefix: 'Superior ' },
            { name: 'epic', weight: 35, powerPerLevel: 3.5, prefix: 'Masterwork ' },
            { name: 'legendary', weight: 25, powerPerLevel: 4, prefix: 'Legendary ' },
            { name: 'mythic', weight: 5, powerPerLevel: 5, prefix: 'Mythic ' }
        ];
    } else {
        rarities = [
            { name: 'epic', weight: 30, powerPerLevel: 3.5, prefix: 'Masterwork ' },
            { name: 'legendary', weight: 45, powerPerLevel: 4, prefix: 'Legendary ' },
            { name: 'mythic', weight: 25, powerPerLevel: 5, prefix: 'Mythic ' }
        ];
    }
} else {
    // Weak item: lower rarity
    rarities = [
        { name: 'common', weight: 60, powerPerLevel: 1.5, prefix: '' },
        { name: 'uncommon', weight: 30, powerPerLevel: 2, prefix: 'Fine ' },
        { name: 'rare', weight: 10, powerPerLevel: 2.5, prefix: 'Superior ' }
    ];
}
    
    // Select rarity
    var totalWeight = rarities.reduce(function(sum, rarity) { return sum + rarity.weight; }, 0);
    var randomWeight = Math.random() * totalWeight;
    var selectedRarity = rarities[0];
    
    var currentWeight = 0;
    for (var i = 0; i < rarities.length; i++) {
        currentWeight += rarities[i].weight;
        if (randomWeight <= currentWeight) {
            selectedRarity = rarities[i];
            break;
        }
    }
    
    // Calculate power based on item level and rarity
var basePower = Math.floor(itemLevel * selectedRarity.powerPerLevel);

// NERF: Reduce defense item power by 40% to balance armor
if (itemType.statType === 'Defense') {
    basePower = Math.floor(basePower * 0.6); // 40% reduction for defense items
}

var finalPower = Math.max(1, basePower);

// Adjust item level based on upgrade/downgrade
// No need to adjust power directly - the item level already determines if it's an upgrade
    
    // Generate name (reuse naming logic from generateUpgradeItem)
    var baseName = itemType.names[Math.floor(Math.random() * itemType.names.length)];
    var fullName = selectedRarity.prefix + baseName;
    
    var materials = [
        'Steel', 'Iron', 'Bronze', 'Copper', 'Silver', 'Gold', 'Platinum',
        'Mithril', 'Adamant', 'Adamantine', 'Orichalcum', 'Titanium',
        'Obsidian', 'Onyx', 'Ruby', 'Sapphire', 'Emerald', 'Diamond',
        'Crystal', 'Jade', 'Ivory', 'Bone', 'Dragonbone', 'Ebony',
        'Darksteel', 'Brightsteel', 'Starmetal', 'Moonstone', 'Sunstone',
        'Volcanic', 'Glacial', 'Abyssal', 'Celestial', 'Infernal',
        'Ancient', 'Elven', 'Dwarven', 'Orcish', 'Demonic', 'Angelic'
    ];
    
    var epicSuffixes = [
        'of Power', 'of Might', 'of Fury', 'of Valor', 'of Glory',
        'of Strength', 'of Protection', 'of the Titan', 'of the Berserker',
        'of the Guardian', 'of the Champion', 'of Conquest', 'of Victory',
        'of Destruction', 'of Domination', 'of Excellence', 'of Perfection',
        'of the Warrior', 'of the Hero', 'of the Legend', 'of Supremacy',
        'of the Storm', 'of Thunder', 'of Lightning', 'of Fire', 'of Ice',
        'of Darkness', 'of Light', 'of Shadow', 'of Radiance'
    ];
    
    var legendaryNames = [
        'Dragonslayer', 'Stormbringer', 'Soulrender', 'Flamestrike', 'Frostbite',
        'Shadowbane', 'Lightbringer', 'Doomblade', 'Excalibur', 'Mjolnir',
        'Gungnir', 'Durandal', 'Gram', 'Tyrfing', 'Caladbolg',
        'Kusanagi', 'Muramasa', 'Masamune', 'Vorpal', 'Reaver',
        'Skullcrusher', 'Heartseeker', 'Souleater', 'Worldender', 'Kingslayer',
        'Demonbane', 'Godsend', 'Eternity', 'Infinity', 'Nemesis',
        'Ragnarok', 'Armageddon', 'Cataclysm', 'Apocalypse', 'Requiem'
    ];
    
    var mythicNames = [
        'Godslayer', 'Worldbreaker', 'Eternity\'s Edge', 'Chaos Reaper', 'Divine Wrath',
        'Oblivion', 'Extinction', 'Annihilation', 'Genesis', 'Omega',
        'Alpha and Omega', 'The Destroyer', 'The Creator', 'Universe Render',
        'Reality Splitter', 'Dimension Breaker', 'Void Caller', 'Existence Ender',
        'The Absolution', 'The Reckoning', 'The Judgment', 'The Harbinger',
        'Primordial Fury', 'Cosmic Terror', 'Celestial Judgment', 'Astral Devastation'
    ];
    
    if (selectedRarity.name === 'rare' && itemLevel >= 15) {
        var material = materials[Math.floor(Math.random() * materials.length)];
        fullName = selectedRarity.prefix + material + ' ' + baseName;
    } else if (selectedRarity.name === 'epic') {
        var suffix = epicSuffixes[Math.floor(Math.random() * epicSuffixes.length)];
        if (Math.random() < 0.5) {
            var material = materials[Math.floor(Math.random() * materials.length)];
            fullName = material + ' ' + baseName + ' ' + suffix;
        } else {
            fullName = selectedRarity.prefix + baseName + ' ' + suffix;
        }
    } else if (selectedRarity.name === 'legendary') {
        if (Math.random() < 0.7) {
            fullName = legendaryNames[Math.floor(Math.random() * legendaryNames.length)];
        } else {
            var material = materials[Math.floor(Math.random() * materials.length)];
            var suffix = epicSuffixes[Math.floor(Math.random() * epicSuffixes.length)];
            fullName = selectedRarity.prefix + material + ' ' + baseName + ' ' + suffix;
        }
    } else if (selectedRarity.name === 'mythic') {
        fullName = mythicNames[Math.floor(Math.random() * mythicNames.length)];
    }
    
    return {
        name: fullName,
        type: itemType.slot,
        slot: itemType.slot,
        power: finalPower,
        level: opponentLevel,
        itemLevel: itemLevel,
        rarity: selectedRarity.name,
        statType: itemType.statType
    };
}
        function generateBossLoot(player, bossLevel, isMythic) {
    var itemTypes = [
        { 
            slot: 'weapon', 
            statType: 'Damage', 
            names: ['Blade', 'Sword', 'Axe', 'Hammer', 'Staff', 'Scythe']
        },
        { 
            slot: 'helmet', 
            statType: 'Defense', 
            names: ['Helm', 'Crown', 'Mask', 'Circlet']
        },
        { 
            slot: 'chest', 
            statType: 'Defense', 
            names: ['Armor', 'Plate', 'Mail', 'Cuirass']
        },
        { 
            slot: 'gloves', 
            statType: 'Defense', 
            names: ['Gauntlets', 'Gloves', 'Grips']
        },
        { 
            slot: 'boots', 
            statType: 'Defense', 
            names: ['Boots', 'Greaves', 'Treads']
        },
        { 
            slot: 'offhand', 
            statType: 'Defense', 
            names: ['Shield', 'Buckler', 'Ward']
        },
        { 
            slot: 'shoulders', 
            statType: 'Defense', 
            names: ['Pauldrons', 'Guards', 'Plates']
        },
        { 
            slot: 'greaves', 
            statType: 'Defense', 
            names: ['Greaves', 'Guards', 'Plates']
        }
    ];
    
    // Select random item type
    var itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
    var baseName = itemType.names[Math.floor(Math.random() * itemType.names.length)];
    
    // Boss item level is higher
    var itemLevel = Math.max(bossLevel, bossLevel + Math.floor(Math.random() * 3));
    
    var rarity, powerPerLevel, prefix;
    
    if (isMythic) {
        rarity = 'mythic';
        powerPerLevel = 5;
        
        // Mythic boss names
        var mythicNames = [
            'Worldbreaker', 'Godslayer', 'Eternity\'s Edge', 'Chaos Reaper', 'Divine Wrath',
            'Oblivion', 'Extinction', 'Annihilation', 'Genesis', 'Omega',
            'The Destroyer', 'Universe Render', 'Reality Splitter', 'Void Caller',
            'The Absolution', 'The Reckoning', 'Primordial Fury', 'Cosmic Terror'
        ];
        baseName = mythicNames[Math.floor(Math.random() * mythicNames.length)];
    } else {
        rarity = 'legendary';
        powerPerLevel = 4;
        
        // Legendary boss names
        var legendaryNames = [
            'Dragonslayer', 'Stormbringer', 'Soulrender', 'Flamestrike', 'Frostbite',
            'Shadowbane', 'Lightbringer', 'Doomblade', 'Excalibur', 'Mjolnir',
            'Vorpal', 'Reaver', 'Skullcrusher', 'Heartseeker', 'Souleater',
            'Worldender', 'Kingslayer', 'Demonbane', 'Godsend', 'Eternity',
            'Nemesis', 'Ragnarok', 'Armageddon', 'Cataclysm', 'Apocalypse'
        ];
        baseName = legendaryNames[Math.floor(Math.random() * legendaryNames.length)];
    }
    
    // Calculate power
    var basePower = Math.floor(itemLevel * powerPerLevel);
    
    // Defense items get 60% power
    if (itemType.statType === 'Defense') {
        basePower = Math.floor(basePower * 0.6);
    }
    
    var finalPower = Math.max(1, basePower);
    
    return {
        name: baseName,
        type: itemType.slot,
        slot: itemType.slot,
        power: finalPower,
        level: bossLevel,
        itemLevel: itemLevel,
        rarity: rarity,
        statType: itemType.statType
    };
}
            
            function levelUp(fighter) {
    fighter.level++;
    fighter.exp -= fighter.expRequired;
    fighter.expRequired = Math.floor(fighter.expRequired * 1.2);
    
    // Increased HP scaling - more HP per level at higher levels
    var hpGain = 20;
    if (fighter.level > 50) {
        hpGain = 50; // +50 HP per level after 50
    } else if (fighter.level > 30) {
        hpGain = 35; // +35 HP per level 31-50
    } else if (fighter.level > 15) {
        hpGain = 25; // +25 HP per level 16-30
    }
    
    fighter.maxHp += hpGain;
    fighter.hp = fighter.maxHp;
    fighter.currentHp = fighter.maxHp;
                
                // Give 1 unallocated stat point instead of random increases
                if (!fighter.unallocatedStats) {
                    fighter.unallocatedStats = 0;
                }
                fighter.unallocatedStats += 1;
                
                var levelUpTexts = [
                    '<span class="level-up">üî• ' + fighter.name + ' has grown stronger and reached Level ' + fighter.level + '! üî•</span>',
                    '<span class="level-up">üî• Through combat experience, ' + fighter.name + ' advances to Level ' + fighter.level + '! üî•</span>',
                    '<span class="level-up">üî• ' + fighter.name + ' feels their power increase as they reach Level ' + fighter.level + '! üî•</span>'
                ];
                addToFightLog(levelUpTexts[Math.floor(Math.random() * levelUpTexts.length)]);
                addToFightLog('<span class="exp-gain">üéØ Gained 1 stat point to allocate! Visit your character screen to spend it.</span>');
                
               // Unlock special attack at level 10
if (fighter.level === 10) {
    fighter.specialAttack = {
        name: generateSpecialAttackName()
    };
    
    // Show modal instead of fight log if we're in combat
    setTimeout(function() {
        showSpecialAttackModal(fighter.name, fighter.specialAttack.name);
    }, 500);
}
            }

        function endFight() {
    document.getElementById('endFightBtn').style.display = 'none';
    
    // Restore the header when leaving fight screen
    var headerContainer = document.querySelector('h1.title');
    if (headerContainer) {
        headerContainer.style.display = 'block';
    }
    
    // Set cooldown timer NOW (when returning to fighter screen) if it was a regular fight
    var fighter = gameState.currentFighter;
    if (fighter && !fighter.isDiamondFight) {
        gameState.fightCooldownEnd = Date.now() + (60 * 1000);
        saveToSupabase();
    }
    
    // Check if player lost to a boss - show rematch modal
    if (gameState.currentFighter && gameState.currentBoss && gameState.currentFighter.didLoseBossFight) {
        gameState.currentFighter.didLoseBossFight = false;
        showRematchModal(gameState.currentBoss);
        return;
    }
    
    // Clear boss data if player won
    gameState.currentBoss = null;
    
    // Check if there's pending loot to show
    if (gameState.currentFighter && gameState.currentFighter.pendingLoot) {
        showLootModal(gameState.currentFighter.pendingLoot);
    } else {
        showFighterScreen();
    }
}
        function showLootModal(item) {
    var fighter = gameState.currentFighter;
    var currentItem = fighter.equipment[item.slot];
    
    // Calculate stat changes
    var statChange = 0;
    var statType = item.statType;
    
    if (currentItem) {
        statChange = item.power - currentItem.power;
    } else {
        statChange = item.power;
    }
    
    // Determine sell price based on rarity
    var sellPrices = {
        'common': 1,
        'uncommon': 2,
        'rare': 3,
        'epic': 5,
        'legendary': 6,
        'mythic': 8
    };
    var sellPrice = sellPrices[item.rarity] || 1;
    
    // Create change indicator
    var changeText = '';
    var changeColor = '';
    if (statChange > 0) {
        changeText = '+' + statChange + ' ' + statType;
        changeColor = '#6bcf7f'; // green
    } else if (statChange < 0) {
        changeText = statChange + ' ' + statType;
        changeColor = '#e74c3c'; // red
    } else {
        changeText = 'No change';
        changeColor = '#888'; // gray
    }
    
    var itemLevelText = item.itemLevel ? 'Lv.' + item.itemLevel + ' ' : '';
    var rarityClass = item.rarity || 'common';
    
    // Build current item display with item level
    var currentItemDisplay = '';
    if (currentItem) {
        var currentItemLevelText = currentItem.itemLevel ? 'Lv.' + currentItem.itemLevel + ' ' : '';
        var currentRarityClass = currentItem.rarity || 'common';
        currentItemDisplay = '<div style="color: #888; font-size: 0.85em;">Currently equipped: <span class="' + currentRarityClass + '">' + currentItemLevelText + currentItem.name + '</span> (+' + (currentItem.power || 0) + ' ' + statType + ')</div>';
    } else {
        currentItemDisplay = '<div style="color: #888; font-size: 0.85em;">Currently equipped: Empty</div>';
    }
    
    var modalHTML = 
        '<div id="lootModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 3px solid #ffd93d; max-width: 450px; width: 90%; text-align: center;">' +
                '<h2 style="color: #ffd93d; margin-bottom: 20px; font-size: 1.8em;">üéÅ LOOT FOUND! üéÅ</h2>' +
                
                '<div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                    '<div class="' + rarityClass + '" style="font-size: 1.3em; font-weight: bold; margin-bottom: 10px;">' +
                        itemLevelText + item.name +
                    '</div>' +
                    '<div style="color: #ffd93d; font-size: 1.1em; margin-bottom: 5px;">+' + item.power + ' ' + item.statType + '</div>' +
                    '<div style="color: #888; font-size: 0.9em; text-transform: capitalize;">' + item.rarity + ' ' + item.slot + '</div>' +
                '</div>' +
                
                '<div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
                    '<div style="font-size: 0.9em; color: #ccc; margin-bottom: 8px;">If equipped:</div>' +
                    '<div style="font-size: 1.2em; font-weight: bold; color: ' + changeColor + ';">' + changeText + '</div>' +
                '</div>' +
                
                '<div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 15px;">' +
                    '<button class="btn btn-primary" onclick="equipLoot()" style="padding: 12px 30px; font-size: 1.1em;">Equip</button>' +
                    '<button class="btn" style="background: #ffd93d; color: #333; padding: 12px 30px; font-size: 1.1em;" onclick="sellLoot(' + sellPrice + ')">Sell (' + sellPrice + ' üíé)</button>' +
                '</div>' +
                
                currentItemDisplay +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

        function showRematchModal(boss) {
    var existingModal = document.getElementById('rematchModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="rematchModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 3000;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8B0000, #4a0000); padding: 30px; border-radius: 10px; border: 3px solid #ff0000; max-width: 450px; width: 90%; text-align: center; box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);">' +
                '<h2 style="color: #ff6b6b; margin-bottom: 20px; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üíÄ DEFEATED üíÄ</h2>' +
                
                '<div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #ff6b6b;">' +
                    '<div style="color: #fff; font-size: 1.2em; margin-bottom: 10px; font-weight: bold;">' + boss.name + ' has crushed you!</div>' +
                    '<div style="color: #ff6b6b; font-size: 1em;">Level ' + boss.level + ' Boss</div>' +
                '</div>' +
                
                '<p style="color: #ccc; margin-bottom: 20px; font-size: 1em; line-height: 1.5;">The boss stands victorious over your fallen body. Will you rise again to challenge this fearsome foe?</p>' +
                
                '<div style="background: rgba(255, 215, 0, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 25px; border: 2px solid #ffd93d;">' +
                    '<div style="color: #ffd93d; font-size: 1.1em; font-weight: bold; margin-bottom: 8px;">‚öîÔ∏è REMATCH AVAILABLE ‚öîÔ∏è</div>' +
                    '<div style="color: #fff; font-size: 0.9em;">Immediately challenge the boss again!</div>' +
                    '<div style="color: #ffd93d; font-size: 1.2em; font-weight: bold; margin-top: 10px;">Cost: 10 üíé</div>' +
                '</div>' +
                
                '<div style="display: flex; flex-direction: column; gap: 15px;">' +
                    '<button class="btn" style="background: #ff0000; color: #fff; padding: 15px 30px; font-size: 1.2em; font-weight: bold; border: 2px solid #fff;" onclick="acceptRematch()" ' + (gameState.diamonds < 10 ? 'disabled' : '') + '>‚öîÔ∏è REMATCH (10 üíé)</button>' +
                    '<button class="btn btn-secondary" onclick="declineRematch()" style="padding: 12px 30px; font-size: 1em;">Retreat</button>' +
                '</div>' +
                
                (gameState.diamonds < 10 ? '<div style="color: #ff6b6b; font-size: 0.9em; margin-top: 15px;">‚ö†Ô∏è Not enough diamonds! You need 10 üíé to rematch.</div>' : '') +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function acceptRematch() {
    var modal = document.getElementById('rematchModal');
    if (modal) {
        modal.remove();
    }
    
    // Check if player has enough diamonds
    if (gameState.diamonds < 10) {
        alert('You need 10 üíé to rematch the boss!');
        showFighterScreen();
        return;
    }
    
    // Deduct diamonds
    gameState.diamonds -= 10;
    saveToSupabase();
    updateDiamondDisplay();
    
    // Get the boss from storage
    var boss = gameState.currentBoss;
    if (!boss) {
        alert('Boss data lost! Returning to character screen.');
        showFighterScreen();
        return;
    }
    
    // Restore player to full HP for rematch
    gameState.currentFighter.hp = gameState.currentFighter.maxHp;
    gameState.currentFighter.currentHp = gameState.currentFighter.maxHp;
    
    // Start the fight again with the same boss
    startFight(gameState.currentFighter, boss, false);
}

function declineRematch() {
    var modal = document.getElementById('rematchModal');
    if (modal) {
        modal.remove();
    }
    
    // Clear boss data
    gameState.currentBoss = null;
    
    // Return to fighter screen
    showFighterScreen();
}
        
function equipLoot() {
    var fighter = gameState.currentFighter;
    if (!fighter || !fighter.pendingLoot) return;
    
    var item = fighter.pendingLoot;
    fighter.equipment[item.slot] = item;
    
    // Clear pending loot
    fighter.pendingLoot = null;
    
    // Save and close
    saveToSupabase();
    closeLootModal();
    
    // Show success message briefly
    showLootMessage('‚úÖ ' + item.name + ' equipped!');
}

function sellLoot(sellPrice) {
    var fighter = gameState.currentFighter;
    if (!fighter || !fighter.pendingLoot) return;
    
    var item = fighter.pendingLoot;
    gameState.diamonds += sellPrice;
    
    // Clear pending loot
    fighter.pendingLoot = null;
    
    // Save and update
    saveToSupabase();
    updateDiamondDisplay();
    closeLootModal();
    
    // Show success message
    showLootMessage('üíé Sold ' + item.name + ' for ' + sellPrice + ' diamonds!');
}

function closeLootModal() {
    var modal = document.getElementById('lootModal');
    if (modal) {
        modal.remove();
    }
    
    // Return to fighter screen
    showFighterScreen();
}

function showLootMessage(message) {
    var existingMsg = document.getElementById('lootMessage');
    if (existingMsg) {
        existingMsg.remove();
    }
    
    var msgHTML = 
        '<div id="lootMessage" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #4ecdc4; color: #fff; padding: 15px 30px; border-radius: 8px; font-weight: bold; z-index: 3500; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">' +
            message +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', msgHTML);
    
    setTimeout(function() {
        var msg = document.getElementById('lootMessage');
        if (msg) {
            msg.style.transition = 'opacity 0.3s ease';
            msg.style.opacity = '0';
            setTimeout(function() {
                msg.remove();
            }, 300);
        }
    }, 2000);
}
// Referral System Functions
function showReferralModal() {
    if (!gameState.currentUser || gameState.currentUser.isGuest) {
        alert('Please create an account to use the referral system!');
        return;
    }
    
    var userId = getUserId();
    var referralLink = window.location.origin + window.location.pathname + '?ref=' + userId;
    
    // Get referral stats
    getReferralStats(userId).then(function(stats) {
        var claimButtonHTML = '';
        
        if (stats.unclaimedRewards > 0) {
            claimButtonHTML = 
                '<div style="background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd93d; border-radius: 8px; padding: 15px; margin-bottom: 20px;">' +
                    '<div style="color: #ffd93d; font-weight: bold; font-size: 1.2em; margin-bottom: 10px;">üíé Unclaimed Rewards!</div>' +
                    '<div style="color: #fff; font-size: 1.1em; margin-bottom: 15px;">' + stats.unclaimedRewards + ' diamonds waiting</div>' +
                    '<button class="btn btn-primary" onclick="claimAllReferralRewards()" style="width: 100%; padding: 12px; font-size: 1.1em; font-weight: bold;">CLAIM ' + stats.unclaimedRewards + ' üíé</button>' +
                '</div>';
        }
        
        var modal = 
            '<div id="referralModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">' +
                '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #4ecdc4; max-width: 500px; width: 90%; text-align: center;">' +
                    '<h2 style="color: #4ecdc4; margin-bottom: 20px;">üéÅ Refer Friends & Earn Rewards!</h2>' +
                    
                    claimButtonHTML +
                    
                    '<div style="background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd93d; border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
                        '<h3 style="color: #ffd93d; margin-bottom: 15px;">How It Works</h3>' +
                        '<div style="text-align: left; color: #ccc; font-size: 0.9em;">' +
                            '<p style="margin-bottom: 10px;">‚úÖ Share your unique referral link</p>' +
                            '<p style="margin-bottom: 10px;">‚úÖ Friend creates account & first fighter</p>' +
                            '<p style="margin-bottom: 10px;">‚úÖ You both get <span style="color: #ffd93d; font-weight: bold;">50 üíé</span></p>' +
                            '<p style="color: #888; font-size: 0.85em; margin-top: 10px;">‚ö†Ô∏è Remember to claim your rewards!</p>' +
                        '</div>' +
                    '</div>' +
                    
                    '<div style="background: rgba(78, 205, 196, 0.2); border: 2px solid #4ecdc4; border-radius: 8px; padding: 15px; margin-bottom: 20px;">' +
                        '<div style="color: #4ecdc4; font-weight: bold; font-size: 1.1em;">Your Stats</div>' +
                        '<div style="color: #fff; margin-top: 10px;">' +
                            '<span style="color: #ffd93d; font-size: 1.5em; font-weight: bold;">' + stats.totalReferred + '</span>' +
                            '<div style="color: #888; font-size: 0.9em;">Friends Referred</div>' +
                        '</div>' +
                        '<div style="color: #fff; margin-top: 10px;">' +
                            '<span style="color: #6bcf7f; font-size: 1.5em; font-weight: bold;">' + stats.totalClaimed + ' üíé</span>' +
                            '<div style="color: #888; font-size: 0.9em;">Total Diamonds Claimed</div>' +
                        '</div>' +
                    '</div>' +
                    
                    '<div style="margin-bottom: 20px;">' +
                        '<label style="color: #4ecdc4; display: block; margin-bottom: 8px; font-weight: bold;">Your Referral Link:</label>' +
                        '<div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px; border: 1px solid #4ecdc4;">' +
                            '<input type="text" value="' + referralLink + '" id="referralLinkInput" readonly onclick="this.select()" style="width: 100%; padding: 10px; background: transparent; border: none; color: #fff; text-align: center; font-size: 0.85em; cursor: pointer;">' +
                        '</div>' +
                    '</div>' +
                    
                    '<div style="display: flex; gap: 10px; margin-bottom: 15px;">' +
                        '<button class="btn btn-primary" onclick="copyReferralLink()" style="flex: 1;">üìã Copy Link</button>' +
                        '<button class="btn" style="background: #1DA1F2; color: #fff; flex: 1;" onclick="shareOnTwitter()">üê¶ Tweet</button>' +
                    '</div>' +
                    
                    '<button class="btn btn-secondary" onclick="closeReferralModal()" style="width: 100%;">Close</button>' +
                '</div>' +
            '</div>';
        
        document.body.insertAdjacentHTML('beforeend', modal);
    });
}

function closeReferralModal() {
    var modal = document.getElementById('referralModal');
    if (modal) modal.remove();
}

function copyReferralLink() {
    var input = document.getElementById('referralLinkInput');
    input.select();
    input.setSelectionRange(0, 99999); // For mobile
    
    try {
        document.execCommand('copy');
        
        // Visual feedback
        var btn = event.target;
        var originalText = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        btn.style.background = '#6bcf7f';
        
        setTimeout(function() {
            btn.innerHTML = originalText;
            btn.style.background = '';
        }, 2000);
    } catch (err) {
        // Fallback for older browsers
        alert('Please manually copy the link: ' + input.value);
    }
}

function shareOnTwitter() {
    var userId = getUserId();
    var text = 'Join me on RandoFight! üéÆ Free browser fighting game with PvP battles, loot, and tournaments. Use my link and we both get 50 diamonds! üíé';
    var url = window.location.origin + window.location.pathname + '?ref=' + userId;
    var twitterUrl = 'https://twitter.com/intent/tweet?text=' + encodeURIComponent(text) + '&url=' + encodeURIComponent(url);
    window.open(twitterUrl, '_blank', 'width=550,height=420');
}

function getReferralStats(userId) {
    return fetch(SUPABASE_URL + '/rest/v1/referrals?referrer_id=eq.' + encodeURIComponent(userId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(referrals) {
        var unclaimedCount = 0;
        var claimedCount = 0;
        
        for (var i = 0; i < referrals.length; i++) {
            if (referrals[i].reward_claimed) {
                claimedCount++;
            } else {
                unclaimedCount++;
            }
        }
        
        return {
            totalReferred: referrals.length,
            unclaimedRewards: unclaimedCount * 50, // 50 diamonds per referral
            totalClaimed: claimedCount * 50
        };
    })
    .catch(function(error) {
        console.error('Error getting referral stats:', error);
        return {
            totalReferred: 0,
            unclaimedRewards: 0,
            totalClaimed: 0
        };
    });
}

function checkReferralCode() {
    var urlParams = new URLSearchParams(window.location.search);
    var referrerId = urlParams.get('ref');
    
    if (referrerId) {
        console.log('Referral code detected:', referrerId);
        localStorage.setItem('randofight_referrer', referrerId);
    }
}

function processReferral(newUserId) {
    var referrerId = localStorage.getItem('randofight_referrer');
    
    if (!referrerId || referrerId === newUserId) {
        localStorage.removeItem('randofight_referrer');
        return;
    }
    
    console.log('Processing referral for new user:', newUserId, 'referred by:', referrerId);
    
    // Check if this referral already exists
    fetch(SUPABASE_URL + '/rest/v1/referrals?referred_id=eq.' + encodeURIComponent(newUserId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        return response.json();
    })
    .then(function(existingReferrals) {
        if (existingReferrals.length > 0) {
            console.log('Referral already processed');
            localStorage.removeItem('randofight_referrer');
            return;
        }
        
        // Create referral record
        var referralData = {
            referrer_id: referrerId,
            referred_id: newUserId,
            created_at: new Date().toISOString(),
            reward_claimed: false
        };
        
        return fetch(SUPABASE_URL + '/rest/v1/referrals', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
            },
            body: JSON.stringify(referralData)
        });
    })
    .then(function(response) {
        if (response && response.ok) {
            console.log('Referral recorded successfully');
            localStorage.removeItem('randofight_referrer');
        }
    })
    .catch(function(error) {
        console.error('Error processing referral:', error);
    });
}

function claimAllReferralRewards() {
    var userId = getUserId();
    
    console.log('Claiming all referral rewards for user:', userId);
    
    // Disable the claim button immediately to prevent double-claiming
    var claimButton = event.target;
    if (claimButton) {
        claimButton.disabled = true;
        claimButton.textContent = 'Claiming...';
    }
    
    // Get ALL referrals for this user
    fetch(SUPABASE_URL + '/rest/v1/referrals?referrer_id=eq.' + encodeURIComponent(userId), {
        method: 'GET',
        headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + SUPABASE_ANON_KEY
        }
    })
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Failed to fetch referrals: ' + response.status);
        }
        return response.json();
    })
    .then(function(allReferrals) {
        console.log('All referrals for user:', allReferrals);
        
        // Filter unclaimed referrals manually
        var unclaimedReferrals = [];
        for (var i = 0; i < allReferrals.length; i++) {
            var ref = allReferrals[i];
            
            // Check both false and null (in case field is null)
            if (ref.reward_claimed === false || ref.reward_claimed === null || ref.reward_claimed === undefined) {
                unclaimedReferrals.push(ref);
            }
        }
        
        console.log('Unclaimed referrals found:', unclaimedReferrals.length);
        
        if (unclaimedReferrals.length === 0) {
            alert('No unclaimed rewards available!');
            closeReferralModal();
            if (claimButton) {
                claimButton.disabled = false;
                claimButton.textContent = 'CLAIM';
            }
            return Promise.reject('No unclaimed rewards');
        }
        
        var totalRewards = unclaimedReferrals.length * 50;
        
        console.log('Total reward to claim:', totalRewards, 'diamonds');
        
        // Mark all referrals as claimed FIRST (without claimed_at field)
        var updatePromises = [];
        for (var i = 0; i < unclaimedReferrals.length; i++) {
            var referral = unclaimedReferrals[i];
            console.log('Updating referral ID:', referral.id);
            
            updatePromises.push(
                fetch(SUPABASE_URL + '/rest/v1/referrals?id=eq.' + referral.id, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        reward_claimed: true
                    })
                })
                .then(function(response) {
                    console.log('Update response status:', response.status);
                    if (!response.ok) {
                        return response.text().then(function(text) {
                            console.error('Update failed:', text);
                            throw new Error('Failed to update referral: ' + response.status);
                        });
                    }
                    return response.json();
                })
                .then(function(result) {
                    console.log('Update successful:', result);
                    return result;
                })
            );
        }
        
        return Promise.all(updatePromises).then(function(results) {
            console.log('All referrals marked as claimed. Results:', results);
            
            // Now award diamonds
            gameState.diamonds += totalRewards;
            updateDiamondDisplay();
            saveToSupabase();
            
            return totalRewards;
        });
    })
    .then(function(totalRewards) {
        console.log('Successfully claimed', totalRewards, 'diamonds');
        
        // Close modal
        closeReferralModal();
        
        // Show success message
        alert('üéâ Successfully claimed ' + totalRewards + ' diamonds! üíé');
    })
    .catch(function(error) {
        console.error('Error claiming referral rewards:', error);
        
        // Re-enable button on error
        if (claimButton) {
            claimButton.disabled = false;
            claimButton.textContent = 'CLAIM';
        }
        
        if (error !== 'No unclaimed rewards') {
            alert('Error claiming rewards. Please try again or contact support.');
        }
    });
}
        function showNewsModal() {
    var existingModal = document.getElementById('newsModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="newsModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 40px; border-radius: 15px; border: 3px solid #ffd93d; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 0 30px rgba(255, 217, 61, 0.3);">' +
                '<h2 style="color: #ffd93d; text-align: center; margin-bottom: 30px; font-size: 2em;">üì∞ Game News & Updates</h2>' +
                
                // Latest update
                '<div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4ecdc4;">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">' +
                        '<h3 style="color: #4ecdc4; margin: 0; font-size: 1.3em;">Version 1.0 Launch!</h3>' +
                        '<span style="color: #888; font-size: 0.85em;">Nov 2025</span>' +
                    '</div>' +
                    '<div style="color: #ccc; font-size: 0.95em; line-height: 1.6;">' +
                        '<p style="margin-bottom: 10px;">üéâ <strong>Welcome to RandoFight!</strong></p>' +
                        '<ul style="margin-left: 20px; margin-bottom: 10px;">' +
                            '<li>‚öîÔ∏è Real-time PvP battles</li>' +
                            '<li>üéØ Battle events system</li>' +
                            '<li>üèÜ Weekly tournaments with prizes</li>' +
                            '<li>üìÖ Daily task rewards</li>' +
                            '<li>üíé Equipment loot system</li>' +
                            '<li>‚ö° Special attacks at level 10</li>' +
                            '<li>üë• Referral rewards</li>' +
                        '</ul>' +
                        '<p style="margin-top: 10px; color: #6bcf7f;"><strong>Thank you for playing!</strong></p>' +
                    '</div>' +
                '</div>' +
                
                // Placeholder for future updates
                '<div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #888;">' +
                    '<h3 style="color: #888; margin: 0 0 10px 0; font-size: 1.1em;">Coming Soon...</h3>' +
                    '<div style="color: #888; font-size: 0.9em;">' +
                        '<p>Stay tuned for future updates and new features!</p>' +
                    '</div>' +
                '</div>' +
                
                '<div style="text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">' +
                    '<p style="color: #666; font-size: 0.8em;">Follow us on social media for the latest news!</p>' +
                '</div>' +
                
                '<button class="btn btn-secondary" onclick="closeNewsModal()" style="width: 100%; margin-top: 20px; padding: 12px;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeNewsModal() {
    var modal = document.getElementById('newsModal');
    if (modal) {
        modal.remove();
    }
}
        
function showCreditsModal() {
    var existingModal = document.getElementById('creditsModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modalHTML = 
        '<div id="creditsModal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; overflow-y: auto;">' +
            '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 40px; border-radius: 15px; border: 3px solid #4ecdc4; max-width: 500px; width: 90%; box-shadow: 0 0 30px rgba(78, 205, 196, 0.3);">' +
                '<h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 2em;">üéÆ RandoFight Credits</h2>' +
                
                '<div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px;">' +
                    '<h3 style="color: #ffd93d; text-align: center; margin-bottom: 15px; font-size: 1.3em;">Developer</h3>' +
                    '<div style="text-align: center; margin-bottom: 15px;">' +
                        '<p style="color: #fff; font-size: 1.1em; margin-bottom: 5px;">JM Contreras</p>' +
                        '<p style="color: #888; font-size: 0.9em;">Lead Developer</p>' +
                    '</div>' +
                '</div>' +
                
                '<div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px;">' +
                    '<h3 style="color: #ffd93d; text-align: center; margin-bottom: 15px; font-size: 1.3em;">Studio</h3>' +
                    '<div style="text-align: center;">' +
                        '<p style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">Ninja Roo Games</p>' +
                        '<img src="https://randofight.com/ninja%20roo%20logo%20white.png" alt="Ninja Roo Games" style="width: 80px; margin: 10px auto; display: block; opacity: 0.8;">' +
                    '</div>' +
                '</div>' +
                
                '<div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 25px;">' +
                    '<h3 style="color: #ffd93d; text-align: center; margin-bottom: 15px; font-size: 1.3em;">Special Thanks</h3>' +
                    '<div style="text-align: center;">' +
                        '<p style="color: #ccc; font-size: 0.95em; margin-bottom: 8px;">‚Ä¢ John Tamala</p>' +
                        '<p style="color: #ccc; font-size: 0.95em; margin-bottom: 8px;">‚Ä¢ Daniel Dabalos</p>' +
                        '<p style="color: #ccc; font-size: 0.95em;">‚Ä¢ Hanniel Espaldon</p>' +
                    '</div>' +
                '</div>' +
                
                '<div style="text-align: center; margin-bottom: 25px;">' +
                    '<p style="color: #888; font-size: 0.9em; margin-bottom: 10px;">Contact Us:</p>' +
                    '<a href="mailto:ninjaroogames@gmail.com" style="color: #4ecdc4; text-decoration: none; font-size: 1em; font-weight: bold;">ninjaroogames@gmail.com</a>' +
                '</div>' +
                
                '<div style="text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">' +
                    '<p style="color: #666; font-size: 0.8em;">¬© 2025 Ninja Roo Games. All rights reserved.</p>' +
                    '<p style="color: #666; font-size: 0.8em; margin-top: 5px;">Version 1.0</p>' +
                '</div>' +
                
                '<button class="btn btn-secondary" onclick="closeCreditsModal()" style="width: 100%; margin-top: 20px; padding: 12px;">Close</button>' +
            '</div>' +
        '</div>';
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeCreditsModal() {
    var modal = document.getElementById('creditsModal');
    if (modal) {
        modal.remove();
    }
}
        
function initGame() {
    console.log('RandoFight initializing...');
    
    updateLoadingProgress(10, 'Initializing...');
    
    // Check for referral code in URL
    checkReferralCode();
    
    // Force clear any password reset tokens first
    console.log('Clearing any existing reset tokens...');
    localStorage.removeItem('reset_token_demo');
    localStorage.removeItem('reset_user_id');
    
    // Initialize EmailJS early
    setTimeout(function() {
        initEmailJS();
    }, 1000);
    
    try {
        // Check if this is a password reset link first (only URL parameters, not localStorage)
        var urlParams = new URLSearchParams(window.location.search);
        var tokenFromURL = urlParams.get('reset');
        
        if (tokenFromURL) {
            console.log('URL reset token found:', tokenFromURL);
            hideLoadingScreen();
            showResetPasswordForm();
            return;
        }
        
        // Check for existing login session
        if (checkExistingSession()) {
            console.log('Valid session found, loading game data...');
            loadFromSupabase();
            showTitleScreen();
        } else {
            console.log('No valid session, showing login screen...');
            updateLoadingProgress(100, 'Ready!');
            setTimeout(function() {
                hideLoadingScreen();
                showLoginScreen();
            }, 300);
        }
    } catch (error) {
        console.error('Init error, forcing login screen:', error);
        hideLoadingScreen();
        showLoginScreen();
    }
    
    setInterval(updateFightStatus, 1000);
}

        // Add a manual cleanup function you can call from browser console
        window.clearResetTokens = function() {
            localStorage.removeItem('reset_token_demo');
            localStorage.removeItem('reset_user_id');
            console.log('Reset tokens cleared');
            location.reload();
        };

        window.addEventListener('load', initGame);
    </script>
</body>
</html>
